You chose the file "C:\Users\P70073624\Desktop\SangitaStuff\SangitaStuff\MicroScaleCodePreconditioningStudy.edp"
-- FreeFem++ v4.5 (mar. 11 f√©vr. 2020 20:59:29 - git v4.5-2-g95135963)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "Element_P3"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\Element_P3 = 0)
    2 : load "UMFPACK64"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\UMFPACK64 = 0)
    3 : load "gmsh"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\gmsh = 0)
    4 : load "medit"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\medit = 0)
    5 :
    6 : include "variableExporter.edp"load "iovtk"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\iovtk = 0) load: iovtk
;
    2 :
    3 : macro variablePath(variableDirectory,simulationName,variableType,extension)( ( (variableDirectory+simulationName)+variableType ) +extension )  )  //
    4 :
    5 : macro itsCool(x1,x2){real k4= x1+x2;} )  //
    6 :
    7 : macro vtkScalarVariableExporter(variableValue,varName, Th, variableDirectory,simulationName,variableType,extension){
    8 #                                 ofstream fileOutput(variablePath(variableDirectory,simulationName,variableType,extension) );
    9 #                                 fespace VhC(Th, P2);
   10 #                                 VhC[int] uh(2);
   11 #                                 uh[0] = x;
   12 #                                 uh[1] = y;
   13 #
   14 #
   15 #                                 int nvertices = Th.nv;
   16 #                                 int ntriangles = Th.nt;
   17 #                                 int size = VhC.ndof;
   18 #
   19 #
   20 #
   21 #
   22 #
   23 #                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 #                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 #                                 fileOutput << "ASCII" << endl;
   26 #                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 #
   28 #
   29 #
   30 #
   31 #                                 real iter=0;
   32 #                                 fileOutput << "POINTS " << size << " double" << endl;
   33 #                                 for ( int i = 0; i < size; i++)
   34 #                                 {
   35 #                                         real Thx = uh[0][][i];
   36 #                                         real Thy = uh[1][][i];
   37 #                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 #                                 }
   39 #                                 fileOutput << endl;
   40 #
   41 #
   42 #
   43 #
   44 #
   45 #
   46 #                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 #                                 for( int i = 0;i<ntriangles; i++)
   48 #                                         {
   49 #                                                 fileOutput << 3 << " ";
   50 #                                                 for(int j = 0; j<3;j++)
   51 #                                                 {
   52 #                                                         fileOutput << VhC(i,j) << " ";
   53 #                                                 }
   54 #                                                 fileOutput << endl;
   55 #                                         }
   56 #
   57 #
   58 #
   59 #
   60 #
   61 #
   62 #                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 #                                 for(int i=0;i<ntriangles;i++)
   64 #                                 {
   65 #                                         fileOutput << "5 ";
   66 #                                 }
   67 #                                 fileOutput << endl;
   68 #
   69 #
   70 #
   71 #
   72 #
   73 #                                 fileOutput << "POINT_DATA " << size << endl;
   74 #                                 fileOutput << " "<< endl;
   75 #                                 int narray = 1;
   76 #                                 string[int] name(narray);
   77 #                                 name[0] = varName ;
   78 #
   79 #                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 #
   81 #
   82 #
   83 #                                 fileOutput <<" " << endl;
   84 #                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 #                                                 for (int i =0; i< size ;i++)
   86 #                                                 {
   87 #
   88 #                                                         real Thx = uh[0][][i];
   89 #                                                         real Thy = uh[1][][i];
   90 #                                                         fileOutput << variableValue(Thx,Thy) <<  endl;
   91 #                                                 }
   92 #
   93 #
   94 #
   95 #
   96 #
   97 #
   98 # } )  //
   99 :
  100 :
  101 :
  102 : macro vtkVectorVariableExporter(variableValueX,variableValueY,varName, Th, variableDirectory,simulationName,variableType,extension){
  103 #                                 ofstream fileOutput(variablePath(variableDirectory,simulationName,variableType,extension) );
  104 #                                 fespace VhC(Th, P2);
  105 #                                 VhC[int] uh(2);
  106 #                                 uh[0] = x;
  107 #                                 uh[1] = y;
  108 #
  109 #
  110 #                                 int nvertices = Th.nv;
  111 #                                 int ntriangles = Th.nt;
  112 #                                 int size = VhC.ndof;
  113 #
  114 #
  115 #
  116 #
  117 #
  118 #                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
  119 #                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
  120 #                                 fileOutput << "ASCII" << endl;
  121 #                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
  122 #
  123 #
  124 #
  125 #
  126 #                                 real iter=0;
  127 #                                 fileOutput << "POINTS " << size << " double" << endl;
  128 #                                 for ( int i = 0; i < size; i++)
  129 #                                 {
  130 #                                         real Thx = uh[0][][i];
  131 #                                         real Thy = uh[1][][i];
  132 #                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
  133 #                                 }
  134 #                                 fileOutput << endl;
  135 #
  136 #
  137 #
  138 #
  139 #
  140 #
  141 #                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
  142 #                                 for( int i = 0;i<ntriangles; i++)
  143 #                                         {
  144 #                                                 fileOutput << 3 << " ";
  145 #                                                 for(int j = 0; j<3;j++)
  146 #                                                 {
  147 #                                                         fileOutput << VhC(i,j) << " ";
  148 #                                                 }
  149 #                                                 fileOutput << endl;
  150 #                                         }
  151 #
  152 #
  153 #
  154 #
  155 #
  156 #
  157 #                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
  158 #                                 for(int i=0;i<ntriangles;i++)
  159 #                                 {
  160 #                                         fileOutput << "5 ";
  161 #                                 }
  162 #                                 fileOutput << endl;
  163 #
  164 #
  165 #
  166 #
  167 #
  168 #                                 fileOutput << "POINT_DATA " << size << endl;
  169 #                                 fileOutput << " "<< endl;
  170 #                                 int narray = 1;
  171 #                                 string[int] name(narray);
  172 #                                 name[0] = varName ;
  173 #
  174 #                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
  175 #
  176 #
  177 #
  178 #                                 fileOutput <<" " << endl;
  179 #                                 fileOutput << name[0] << " 3 " << size <<" double" << endl;
  180 #                                                 for (int i =0; i< size ;i++)
  181 #                                                 {
  182 #
  183 #                                                         real Thx = uh[0][][i];
  184 #                                                         real Thy = uh[1][][i];
  185 #                                                         fileOutput << variableValueX(Thx,Thy) << " "<< variableValueY(Thx,Thy) <<" 0"<< endl;
  186 #                                                 }
  187 #
  188 #
  189 #
  190 #
  191 #
  192 #
  193 # } )  //
  194 :
    7 : include "2D_Macros.edp"
    2 : //useful macros
    3 : //Various stress-tensor macros, helpful for different formulations of the diffusive term.
    4 : macro vectorLaplacian(uxh,uyh)[-(dxx(uxh)+dyy(uxh)),-(dxx(uyh)+dyy(uyh))] )  //
    5 : macro vectorGrad(uxh,uyh)[[dx(uxh),dy(uxh)],[dx(uyh),dy(uyh)] ] )  //
    6 : macro vectorGradDoubleDot(ux,uy)[dx(ux),dy(ux),dx(uy),dy(uy) ] )  //
    7 : macro terminePressure(ux,uy,p) (p*(dx(ux)+dy(uy)) ) )  //
    8 : macro skewSym(ux,uy)     [ [0, .5*(dy(ux)-dx(uy))], [.5*(dx(uy)-dy(ux)),0]]  )  //
    9 : macro skewSymDoubleDot(ux,uy)  [.5*(dy(ux)-dx(uy)),.5*(dx(uy)-dy(ux))]  )  //
   10 : macro stressTensor(ux,uy)     [[dx(ux), .5*(dy(ux)+dx(uy))],[ .5*(dx(uy)+dy(ux)),dy(uy)]] )  //
   11 : macro stressTensorDoubleDot(ux,uy) [dx(ux), .5*(dy(ux)+dx(uy)), .5*(dx(uy)+dy(ux)),dy(uy) ]  )  //
   12 : macro termineDiffusiva(ux,uy,vx,vy) (2*stressTensorDoubleDot(ux,uy)'*vectorGradDoubleDot(vx,vy)) )  //
   13 : macro termineDiffusivaLaplace(ux,uy,vx,vy) (vectorGradDoubleDot(ux,uy)'*vectorGradDoubleDot(vx,vy)) )  //
   14 : macro divSym(ux,uy)     [dxx(ux)+ .5*(dyy(ux)+dxy(uy)), .5*(dxx(uy)+dyx(ux))+dyy(uy)] )  //
   15 : macro stressTensor2(p) [ [p,0],[0, p]]  )  //
   16 : macro vectorDiv(ux,uy)(dx(ux)+dy(uy) ) )  //
   17 : macro gradDivStab(ux,uy,vx,vy)( (dx(ux)+dy(uy))*(dx(vx)+dy(vy)) )  )  //
   18 : macro neumannBoundaryLaplace(uxh,uyh,vxh,vyh,p,nu) ( (nu*vectorGrad(uxh,uyh)*[N.x,N.y])'*[vxh,vyh]-p*[N.x,N.y]'*[vxh,vyh] )  )  //
   19 : macro neumannBoundaryFullTensor(uxh,uyh,vxh,vyh,p,nu) ( (nu*stressTensor(uxh,uyh)*[N.x,N.y])'*[vxh,vyh]-p*[N.x,N.y]'*[vxh,vyh] )  )  //
   20 : macro computeWSS(nu,uxh,uyh)( nu*stressTensor(uxh,uyh)*[N.x,N.y] - nu*((stressTensor(uxh,uyh)*[N.x,N.y])'*[N.x,N.y])*[N.x,N.y])  )  //
   21 : //macro computeWSSAxi(nu,uxh,uyh)( (nu*axiNormal*stressTensor(uxh,uyh)*[0,N.y] + axiNormal*nu*(1./y)*uyh*[0,N.y] - nu*((axiNormal*stressTensor(uxh,uyh)*[0,N.y])'*[0,N.y]*axiNormal)*[0,N.y]*axiNormal - nu*(1./y)*((uyh*axiNormal*[0,N.y])'*[0,N.y]*axiNormal)*[0,N.y]*axiNormal) ) //
   22 : //Macros for the trilinear form
   23 : macro UdotGradU (upx,upy,ux,uy)[upx*dx(ux)+upy*dy(ux), upx*dx(uy) + upy*dy(uy) ]  )  //
   24 : macro formaTrilinare(upx,upy,ux,uy,vx,vy) (UdotGradU(upx,upy,ux,uy)'*[vx,vy] )  )  //
   25 : macro formaTrilinareLeo(upx,upy,ux,uy,vx,vy) (.5*UdotGradU(upx,upy,ux,uy)'*[vx,vy] - .5*UdotGradU(upx,upy,vx,vy)'*[ux,uy] )  )  //
   26 :
   27 :
   28 :
   29 : //Macro for strongly consistent stabilization techniques
   30 : macro pGrad(p)[dx(p),dy(p) ]  )  //
   31 :
   32 : //macro supgTerm(ux,uy,upx,upy,p)[ nu*vectorLaplacian(ux,uy) + UdotGradU(upx,upy,ux,uy)+ pGrad(p) ]//
   33 : macro stabTerm1(ux,uy,upx,upy,p,nu)[-nu*dxx(ux)-nu*dyy(ux)+upx*dx(ux)+upy*dy(ux)+dx(p),
   34 #                                                                         -nu*dxx(uy)-nu*dyy(uy)+upx*dx(uy)+upy*dy(uy)+dy(p) ] )  //
   35 : macro galsStabTerm2(ux,uy,upx,upy,p,nu)[-nu*dxx(ux)-nu*dyy(ux)+upx*dx(ux)+upy*dy(ux)+dx(p),
   36 #                                                                             -nu*dxx(uy)-nu*dyy(uy)+upx*dx(uy)+upy*dy(uy)+dy(p) ] )  //
   37 : macro supgStabTerm2(ux,uy,upx,upy,p)[upx*dx(ux) + upy*dy(ux) + dx(p),
   38 #                                                                          upx*dx(uy) + upy*dy(uy) + dy(p) ]  )  //
   39 : macro modStabTerm1(ux,uy,ix,iy,p,nu)[-nu*dxx(ux)-nu*dyy(ux)+ix*dx(ux)+iy*dy(ux)+dx(p),
   40 #                                                                                                  -nu*dxx(uy)-nu*dyy(uy)+ix*dx(uy)+iy*dy(uy)+dy(p) ] )  //
   41 : macro modStabExplTerm(upx,upy,diffx,diffy)[diffx*dx(upx) + diffy*dy(upx),
   42 #                                                                                    diffx*dx(upy)+diffy*dy(upy) ] )  //
   43 : macro modStabTerm2SUPG(ux,uy,ix,iy,p,nu)[ix*dx(ux) + iy*dy(ux) + dx(p),
   44 #                                                                       ix*dx(uy) + iy*dy(uy) + dy(p) ]  )  //
   45 : macro modStabTerm2GALS(ux,uy,ix,iy,p,nu)[-nu*dxx(ux)-nu*dyy(ux)+ix*dx(ux)+iy*dy(ux)+dx(p),
   46 #                                                                              -nu*dxx(uy)-nu*dyy(uy)+ix*dx(uy)+iy*dy(uy)+dy(p) ] )  //
   47 : macro galsStab(ux,uy,upx,upy,vx,vy,p,q,nu)( stabTerm1(ux,uy,upx,upy,p,nu)'*galsStabTerm2(vx,vy,upx,upy,q,nu) )
)  //
   48 : macro supgStab(ux,uy,upx,upy,vx,vy,p,q,nu)( stabTerm1(ux,uy,upx,upy,p,nu)'*supgStabTerm2(vx,vy,upx,upy,q) )  )
//
   49 : macro modStab(ux,uy,ix,iy,vx,vy,p,q,nu)( modStabTerm1(ux,uy,ix,iy,p,nu)'*modStabTerm2SUPG(vx,vy,ix,iy,q,nu) ) )
 //
   50 : macro modStabExp(upx,upy,diffx,diffy,ix,iy,vx,vy,p,q,nu)( modStabExplTerm(upx,upy,diffx,diffy)'*modStabTerm2SUPG(vx,vy,ix,iy,q,nu) ) )  //
   51 : macro modStabAsym(ux,uy,upx,upy,ix,iy,vx,vy,p,q,nu)( modStabTerm1(ux,uy,upx,upy,p,nu)'*modStabTerm2SUPG(vx,vy,ix,iy,q,nu) ) )  //
   52 :
   53 : //Macros for linear kinetic formulation
   54 : macro kineticVelocityStressGrad(ux,uy,Txx,Txy,Tyx,Tyy)(vectorGradDoubleDot(ux,uy)'*[Txx,Txy,Tyx,Tyy])  )  //
   55 : macro kineticVelocityStressTensor(ux,uy,Txx,Txy,Tyx,Tyy)(2*stressTensorDoubleDot(ux,uy)'*[Txx,Txy,Tyx,Tyy])  )
//
   56 :
   57 : macro tensorDiv(Txx,Txy,Tyx,Tyy) ( [dx(Txx)+dy(Txy), dx(Tyx)+dy(Tyy) ] ) )  //
   58 : macro kineticVelocityStressGradIBP(ux,uy,Txx,Txy,Tyx,Tyy)( [ux,uy]'*tensorDiv(Txx,Txy,Tyx,Tyy) )  )  //
   59 : macro kineticVelocityBoundaryTerm(Txx,Txy,Tyx,Tyy)( [ [Txx, Txy],[Tyx, Tyy] ] )  )  //
   60 : macro kineticVelocityDiadicProduct(uxold,uyold,uxh,uyh)( [uxh*uxold, uxh*uyold, uyh*uxold,uyh*uyold ]  )  )  //
 
   61 : macro kineticVelocityDiadicProductTensor(uxold,uyold,uxh,uyh)( [ [uxh*uxold, uxh*uyold], [uyh*uxold,uyh*uyold] ]  )  )  //
   62 :
   63 : macro kineticVelocityNonlinearTerm(uxold,uyold,uxh,uyh,Txx,Txy,Tyx,Tyy)( kineticVelocityDiadicProduct(uxold,uyold,uxh,uyh)'*[Txx,Txy,Tyx,Tyy]  )  )  //
   64 :
   65 :
   66 : //Useful for residual computation:
   67 : macro checkVectorResidual(ux1,uy1,ux2,uy2) ( sqrt( abs( int2d(Th)( (ux1-ux2)^2 + (uy1-uy2)^2) ) ) )  )  //
 
   68 : macro checkVectorResidualMesh(ux1,uy1,ux2,uy2,msh) ( sqrt( abs( int2d(msh)( (ux1-ux2)^2 + (uy1-uy2)^2) ) ) )  )
 //
   69 : macro vectorNorm(ux,uy)( sqrt( abs(int2d(Th) (ux^2+uy^2) ) ) ) )  //
   70 : macro vectorNormMesh(ux,uy,msh)( sqrt( abs(int2d(msh) (ux^2+uy^2) ) ) ) )  //
   71 :
   72 : macro checkScalarResidual(p1,p2,Th) ( sqrt(abs(int2d(Th)( (p1-p2)^2) ) ) )  )  //
   73 : macro scalarNorm(p,Th) (sqrt(abs(int2d(Th)(p^2) ) ) )  )  //
   74 : macro checkVectorRelativeResidual(ux1,uy1,ux2,uy2)(checkVectorResidual(ux1,uy1,ux2,uy2)/vectorNorm(ux2,uy2) ) )
 //
   75 : macro checkVectorRelativeResidualMesh(ux1,uy1,ux2,uy2,msh)(checkVectorResidualMesh(ux1,uy1,ux2,uy2,msh)/vectorNormMesh(ux2,uy2,msh) ) )  //
   76 :
   77 : macro checkScalarRelativeResidual(p1,p2,Th)(checkScalarResidual(p1,p2,Th)/scalarNorm(p2,Th) ) )  //
   78 : //I don't really use these, but if you want to monitor residuals with velocity and pressure they're useful.
   79 : macro checkVectorScalarResidual(ux,uy,upx,upy,p,pp)(sqrt(abs(int2d(Th)((ux-upx)^2+(uy-upy)^2+ (p-pp)^2 ) ) ) )
)  //
   80 : macro vectorScalarNorm(ux,uy,p)(sqrt(abs(int2d(Th)((ux)^2+(uy)^2 +(p)^2 ) ) ) )  )  //
   81 : macro checkVectorScalarRelativeResidual(ux,uy,upx,upy,p,pp)(checkVectorScalarResidual(ux,uy,upx,upy,p,pp)/vectorScalarNorm(upx,upy,pp) )  )  //
   82 : macro checkVectorScalarVecNorm(ux,uy,p)(ux[].linfty+uy[].linfty+p[].linfty)  )  //
   83 : macro vectorH1Norm(ux,uy) ( sqrt( abs(int2d(Th) (ux^2+uy^2 +dx(ux)^2+dy(ux)^2+dx(uy)^2+dy(uy)^2) ) ) )  )  //
   84 :
   85 : macro checkVectorH1Residual(ux1,uy1,ux2,uy2)  sqrt( abs ( int2d(Th)( (ux1-ux2)^2 + (uy1-uy2)^2 + ( dx(ux1)-dx(ux2))^2 + (dx(uy1)-dx(uy2))^2 +  (dy(ux1)-dy(ux2))^2 + (dy(uy1)-dy(uy2))^2 ) ) )  )  //
   86 : macro checkVectorH1RelativeResidual(ux1,uy1,ux2,uy2) ( checkVectorH1Residual(ux1,uy1,ux2,uy2)/vectorH1Norm(ux2,uy2) )  )  //
   87 : macro matrixH1Norm(K,uxh)(sqrt(abs( (uxh)'*(K*uxh) ) ) )  )  //
   88 : macro checkFlux(uxh,uyh,lab)( int1d(Th,lab)([uxh,uyh]'*[N.x,N.y] )  )  )  //
   89 : //macro steadyResidualVector(uxh,uyh,ph,nu) ( [ -nu*dxx(uxh) - nu*dyy(uxh) + uxh*dx(uxh)+uyh*dy(uxh) + dx(ph) ,
  -nu*dxx(uyh) - nu*dyy(uyh) + uxh*dx(uyh)+uyh*dy(uyh) + dy(ph) ]    ) //
   90 : //macro checkSteadyResidualNoForcing(uxh,uyh,ph,nu) ( steadyResidualVector(uxh,uyh,ph,nu)'*steadyResidualVector(uxh,uyh,ph,nu)    ) //
   91 : macro checkSteadyResidualNoForcing(uxh,uyh,ph,nu,vxh,vyh) ( -nu*termineDiffusivaLaplace(uxh,uyh,vxh,vyh) +  formaTrilinare(uxh,uyh,uxh,uyh,vxh,vyh) - terminePressure(vxh,vyh,ph)     )  )  //
   92 : macro initiateGlobalMesh(x0,y0,L,Hstart,Hfinal,nX,nY, boundaryLabel,flag) (square(L*nX, (Hstart/Hfinal)*nY, [x0
+ L*x, y0 + Hstart*y],label=boundaryLabel,flags=flag ) )  )  //  ˇ
    8 : //include "MeshPlay.edp"
    9 :
   10 : //calcolo il normal. perche' c'e' un scaling (inizialmente dichiaro una geometria con L 80, poi lo riscalo), c'e' questo fattore di 4
   11 : macro funcDeriv(tort,r,buffer,L) ( 0. + tort*r*pi*cos(4.*r*pi*x)*(x>.25*buffer && x < .25*(L - buffer)) )  )  // 
   12 : macro normalVector(tort,r,buffer,L) ( (1./sqrt(1.+funcDeriv(tort,r,buffer,L)*funcDeriv(tort,r,buffer,L)))*[1.,-funcDeriv(tort,r,buffer,L)] ) )  //
   13 : //calcolo pure il WSS
   14 : macro computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)( (nu*stressTensor(uxh,uyh)*normalVector(tort,r,buffer,L) -nu*((stressTensor(uxh,uyh)*normalVector(tort,r,buffer,L))'*normalVector(tort,r,buffer,L))*normalVector(tort,r,buffer,L)  )  )
 //
   15 :
   16 : //macro computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))( (nu*axiNormal*stressTensor(uxh,uyh)*[0,N.y] - nu*((axiNormal*stressTensor(uxh,uyh)*[0,N.y])'*[0,N.y]*axiNormal)*[0,N.y]*axiNormal ) ) //
   17 : macro axiNormal() ((1./y) )//
   18 :
   19 : //macro che servono varie robe
   20 : macro WSSMag(nu,uxh,uyh)(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))))) )  ///
   21 : //macro WSSSigmoid4(threshhold,nu,uxh,uyh,tort,r,buffer,L)(( exp(- ( sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))-threshhold))) ))/(1.+exp(- ( sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))-threshhold))) )) )//
   22 : macro WSSSigmoid2(threshhold,nu,uxh,uyh)( exp(-(y-2.))/(1.+exp(-(y-2.))) )  )  //
   23 : macro WSSSigmoid5(threshhold,nu,uxh,uyh)( exp(-(sqrt([uxh,uyh]'*[uxh,uyh])-threshhold))/(1.+exp(-(sqrt([uxh,uyh]'*[uxh,uyh])-threshhold))) )  )  //
   24 : //macro WSSSigmoid4(threshhold,nu,uxh,uyh,tort,r,buffer,L)( exp(-35.*(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))-threshhold))/(1.+exp(-35.*(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))-threshhold))) ) //
   25 : //macro WSSSigmoid4(threshhold,nu,uxh,uyh,tort,r,buffer,L)( exp(-.0001*(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))-threshhold))/(1.+ exp(-.0001*(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))-threshhold)) )))) )  )//
   26 : //macro WSSSigmoid4(threshhold,nu,uxh,uyh,tort,r,buffer,L)( exp(-1.*(sqrt(abs(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))-threshhold))/(1.+ exp(-1.*(sqrt(abs(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))-threshhold)) )))) )  )//
   27 : //macro WSSSigmoid4(threshhold,nu,uxh,uyh,tort,r,buffer,L )  ( exp(-35.*(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))-threshhold))/(1.+exp(-35.*(sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))-threshhold))) ) //
   28 : macro WSSSigmoid4(threshhold,nu,uxh,uyh,tort,r,buffer,L )  ( exp(-2.5*(sqrt(abs(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))))-threshhold))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))))-threshhold))) )  )  //
   29 : macro WSSSigmoid3(threshhold,nu,ph)( exp(-20.*(ph-threshhold))/(1.+exp(-20.*(ph-threshhold))) )  )  //
   30 : //macro WSSQuickComp(nu,uxh,uyh,tort,r,buffer,L) (sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)))//
   31 : macro WSSQuickComp(nu,uxh,uyh,tort,r,buffer,L) (sqrt(computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L)'*computeWSSAxi(nu,uxh,uyh,tort,r,buffer,L))))) )  //
   32 : //label il sangue e dialysate
   33 : int[int] bloodLabels=[1,2,3,4];
   34 : int[int] dialysateLabels=[5,6,7,8];
   35 : int [int] membraneLabels=[9,10,11,12];
   36 : //il fattore che viene usato per riscalare dal lunghezza 80 in lunghezza 20
   37 : real shrinkFactor=.25;
   38 : //output un file che ricorda varie risultati della simulazioen
   39 : bool gridConvergenceStudy=true;
   40 : string directory="./";
   41 : string simulationName="Steady.txt";
   42 : string meshAppend="Test.txt";
   43 : //string meshAppend="GaussSeidelPreconditioners.txt";
   44 :
   45 : //la cartella per x il vtk
   46 : string simResults="./SangitaResults/";
   47 : string outputFile=directory+simulationName;
   48 :
   49 : //parametri fisici
   50 : real dt=1.; real nuBlood=3.; real nuDial=1.; real gradDiv=100.; real rhoBlood=1.0*1.; real rhoDial=1.00*1.;
   51 : //real dialysateSoluteDiffusion=.012585; real bloodSoluteDiffusion=.012585;
   52 : real dialysateSoluteDiffusion=.00181; real bloodSoluteDiffusion=.000929;
   53 :
   54 : real tolerance=1e-6; real transportTol=1e-6;
   55 : bool exportFlow=true;
   56 : bool importFlow=false;
   57 :
   58 : //tipo di solutore, monolithic e' sempre quello piu' veloce
   59 : string transportSolverType="monolithic";
   60 : string transportPreconditioner="gauss-seidel";
   61 : cout<<"Enter torturosity"<<endl;
   62 : real tortuosity;
   63 :
   64 :
   65 : //maxIterations is for N-S solve, numStepsMix is for the transport equations.
   66 : int maxIterations=500; int numStepsMix=500; int subIterations=-1;
   67 :
   68 : //geometric parameters
   69 : real L=80.;
   70 : real bloodWidth=2.;
   71 : real dialysateWidth=1.;
   72 : real membraneWidth=0.;//.72/2.;
   73 : //risoluzione del mesh
   74 : real n=8.; int waveResolution=4;
   75 : //input di tortorsity
   76 : cin >> tortuosity;
   77 : //frequenza delle onde
   78 : real rapidity=.5; real baseline=1.;
   79 : //l'area di influssi e outflussi prima iniziano le onde
   80 : real bufferZone=3.*4.;
   81 :
   82 :
   83 : //func gBlood= (shrinkFactor*5.)*((8.*.75)*((shrinkFactor*bloodWidth)+y)*((shrinkFactor*bloodWidth)-y))/((shrinkFactor*bloodWidth)^2);;
   84 : //func gDial= (shrinkFactor*10.)*((8.*.75)*(shrinkFactor*bloodWidth-y)*((shrinkFactor*bloodWidth+shrinkFactor*dialysateWidth)-y))/((shrinkFactor*dialysateWidth)^2);
   85 : //func gBlood= (.67*.0166667)*((8.*.75)*((shrinkFactor*bloodWidth)+y)*((shrinkFactor*bloodWidth)-y))/((shrinkFactor*bloodWidth)^2);;
   86 : //func gDial= (1.33*.016667)*((8.*.75)*(shrinkFactor*bloodWidth-y)*((shrinkFactor*bloodWidth+shrinkFactor*dialysateWidth)-y))/((shrinkFactor*dialysateWidth)^2);
   87 : //func gBlood= (8.*(1.33)*1.667/(2.*pi))*((8.*.75)*((shrinkFactor*bloodWidth)+y)*((shrinkFactor*bloodWidth)-y))/((shrinkFactor*bloodWidth)^2);;
   88 : //func gDial= (8.*2.*(1.33)*1.667/(2.*pi))*((8.*.75)*(shrinkFactor*bloodWidth-y)*((shrinkFactor*bloodWidth+shrinkFactor*dialysateWidth)-y))/((shrinkFactor*dialysateWidth)^2);
   89 : func gBlood= (8.*(4./3.)*(5./3)/(2.*pi))*((8.*.75)*((shrinkFactor*dialysateWidth)+y)*((shrinkFactor*dialysateWidth)-y))/((shrinkFactor*dialysateWidth)^2);;
   90 : func gDial= (4.*2.*(1.)*(5./3.)/(2.*pi))*((8.*.75)*(shrinkFactor*dialysateWidth-y)*((shrinkFactor*bloodWidth+shrinkFactor*dialysateWidth)-y))/((shrinkFactor*bloodWidth)^2);
   91 : //func gBlood= (0.0166666666)*((8.*.75)*((bloodWidth)+y)*((bloodWidth)-y))/((bloodWidth)^2);;
   92 : //func gDial= (0.0166666666*2.)*((8.*.75)*(bloodWidth-y)*((bloodWidth+dialysateWidth)-y))/((dialysateWidth)^2);
   93 :
   94 :
   95 : real K=1.; real p=1.; real wssThresh;/*=4.*42.5;*/ real vMaxPar=1.; real kappa=0.01;
   96 : //qui metti pure il valore di WSS/8 che serve come threshhold
   97 : cout<<"Enter wss threshold"<<endl;
   98 : cin >> wssThresh;
   99 : //non so perche' dobbiamo multiplicare questo da due... per il sigmoid sembra che serve la meta' del valore "vero"
  100 : wssThresh=4.*wssThresh;
  101 : //declare meshes
  102 : //func gBlood=     4.*(.75*y*(bloodHeight-y))/(2^2);
  103 : //func gDial=     4.*(.75*((inlet+outerRad-outWidth)-x)*(inlet+outerRad-x))/(2^2);
  104 : //func gDial=     4*(.75*y*(bloodHeight-y))/(2^2);
  105 : //func gBlood=     4*(.75*((inlet+outerRad-outWidth)-x)*(inlet+outerRad-x))/(2^2);
  106 :
  107 :
  108 : border one(t=0.,dialysateWidth){x=t;y=0.;label=1;}
  109 : border two(t=0.,bufferZone){x=dialysateWidth;y=t;label=4;}
  110 : border three(t=bufferZone,L-bufferZone){x=dialysateWidth+tortuosity*sin(rapidity*pi*t);y=t;label=4;}
  111 : border four(t=L-bufferZone,L){x=dialysateWidth;y=t;label=4;}
  112 : border five(t=dialysateWidth,0.){x=t;y=L;label=3;}
  113 : border six(t=L,0.){x=0.;y=t;label=2;}
  114 : mesh ThDialA =buildmesh (one(2*n)+two(waveResolution*bufferZone*n)+three(waveResolution*(L-2*bufferZone)*n)+four(waveResolution*bufferZone*n)+five(2*n)+six(L*n) );
  115 : //ThDial=movemesh(ThDial,[y,x]);
  116 :
  117 : border seven(t=dialysateWidth,dialysateWidth+bloodWidth){x=t;y=0.;label=5;}
  118 : border eight(t=0.,L){x=dialysateWidth+bloodWidth;y=t;label=8;}
  119 : border nine(t=dialysateWidth+bloodWidth,dialysateWidth){x=t;y=L;label=7;}
  120 : border ten(t=L,L-bufferZone){x=dialysateWidth;y=t;label=6;}
  121 :
  122 : border eleven(t=L-bufferZone,bufferZone){x=dialysateWidth+tortuosity*sin(rapidity*pi*t);y=t;label=6;}
  123 : border twelve(t=bufferZone,0.){x=dialysateWidth;y=t;label=6;}
  124 : mesh ThBlood =buildmesh (seven(2*n)+eight(L*n)+nine(2*n)+ten(waveResolution*bufferZone*n)+eleven((L-2*bufferZone)*waveResolution*n)+twelve(bufferZone*n*waveResolution) );
  125 : mesh ThDial=movemesh(ThBlood,[shrinkFactor*y,shrinkFactor*x]);
  126 : ThBlood=movemesh(ThDialA,[shrinkFactor*y,shrinkFactor*x]);
  127 : savemesh(ThDial,"./DialMesh.mesh");
  128 : savemesh(ThBlood,"./BloodMesh.mesh");
  129 :
  130 : plot(ThBlood,ThDial);
  131 : //blood fe spaces
  132 : fespace VhBlood(ThBlood,[P2,P2]);
  133 : fespace QhBlood(ThBlood,P1);
  134 : //dialysate fe spaces
  135 : fespace VhDial(ThDial,[P2,P2]);
  136 : fespace QhDial(ThDial, P1);
  137 : fespace DialMesh(ThDial,P0);
  138 : fespace BloodMesh(ThBlood,P0);
  139 :
  140 : DialMesh hDial;
  141 : BloodMesh hBlood;
  142 : hDial=hTriangle;
  143 : hBlood=hTriangle;
  144 : VhBlood [bxh, byh];
  145 : VhBlood [bxLast, byLast];
  146 : VhBlood [bxT, byT];
  147 : QhBlood pbh, cbh, qbh,cbhLast, cbhLast2,cbhOld, WSSSig, WSSVal, pbT;
  148 : VhBlood [vxbh, vybh];
  149 : VhBlood [bxWSS, byWSS];
  150 :
  151 :
  152 : VhDial [dxh, dyh];
  153 : VhDial [dxLast, dyLast];
  154 : QhDial pdh, cdh, qdh, cdhLast, cdhLast2,cdhOld;
  155 : VhDial [vxdh, vydh];
  156 :
  157 : cbhLast=0.00;
  158 : cdhLast=.000;
  159 :
  160 : if(exportFlow==true && importFlow==true)
  161 : {
  162 :         cout<<"Cannot both export and import flow! Exporting flo
  ... : w!"<<endl;
  163 :         importFlow=false;
  164 : }
  165 :
  166 : //variational forms for transport equations
  167 : varf dialysateBEVarf(cdh,qdh)=
  168 : //      int2d(ThDial)(cdh*qdh)
  169 :         int2d(ThDial)(y*1.*dialysateSoluteDiffusion*(dx(cdh)*dx(qdh)+dy(cdh)*dy(qdh))  )
  170 :         +int2d(ThDial)(y*([dxh,dyh]'*[dx(cdh),dy(cdh)])*qdh )
  171 : //WSS Sigmoid
  172 :         +int1d(ThBlood,4)(y*vMaxPar*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)  (sqrt(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
*funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) '*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity,
rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) ))))/wssThresh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)       ( exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
            ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. +
tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)
           [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.*
rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
    ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone
&& x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone &&
x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone))
) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x
< .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))) ) *dt*K*(cdh*1.)*qdh)
  173 : //      +int1d(ThBlood,4)(y*vMaxPar*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)*dt*K*(cdh*1.)*qdh)
  174 :         +on(7,cdh=0.0)
  175 :         ;
  176 :
  177 : varf dialysateBERHS(cdh,qdh)=
  178 : //WSS Sigmoid
  179 :         -int1d(ThDial,6)(y*vMaxPar*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)  (sqrt(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L
- bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone,
L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x <
.25*( L - bufferZone)) ) ] )  ) '*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. +
tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) ))))/wssThresh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)       ( exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
           ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
         ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
     ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone
&& x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone,
L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity*
rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L -
bufferZone)) ) ] )  ) )))-wssThresh))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
     ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone
&& x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)
          [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
   ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
         ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))) ) *dt*K*(-1.*cbh*1.)*qdh)
  180 :         ;
  181 :
  182 : //blood forms: BE
  183 : varf bloodBEVarf(cbh,qbh)=
  184 :         int2d(ThBlood)( y*bloodSoluteDiffusion*(dx(cbh)*dx(qbh)+dy(cbh)*dy(qbh)) )
  185 :         +int2d(ThBlood)(y*([bxh,byh]'*[dx(cbh),dy(cbh)])*qbh )
  186 : //WSS Sigmoid
  187 :         +int1d(ThBlood,4)(y*vMaxPar*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)  (sqrt(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
*funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) '*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity,
rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) ))))/wssThresh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)       ( exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
            ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. +
tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)
           [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.*
rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
    ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone
&& x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone &&
x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone))
) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x
< .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))) ) *dt*K*(cbh*1.)*qbh)
  188 :         +on(1,cbh=1.)
  189 :         ;
  190 :
  191 : varf bloodBERHS(cbh,qbh)=
  192 : //WSS Sigmoid
  193 : //      -int1d(ThBlood,4)(y*(cbhOld/(kappa+cbhOld))*vMaxPar*WSSQuickComp(nuBlood,bxh,byh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh)*dt*K*(-cdhOld*1.)*qbh)
  194 :         -int1d(ThBlood,4)(y*vMaxPar*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)  (sqrt(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
*funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) '*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity,
rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) ))))/wssThresh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)       ( exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
            ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. +
tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)
           [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.*
rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
    ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone
&& x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone &&
x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone))
) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x
< .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))) ) *dt*K*(-cdhOld*1.)*qbh)
  195 :         ;
  196 :
  197 : varf bloodBERHSMat(cdh,qbh)=
  198 : //WSS Sigmoid
  199 :         -int1d(ThBlood,4)(y*vMaxPar*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)  (sqrt(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
*funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) '*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity,
rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) ))))/wssThresh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)       ( exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
            ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. +
tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) )
))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
      ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)
           [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.*
rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
    ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone
&& x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone &&
x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone))
) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x
< .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
          ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))) ) *dt*K*(cdh*1.)*qbh)
  200 :         ;
  201 :
  202 :
  203 :
  204 : problem stokesBlood([bxh,byh,pbh],[vxbh,vybh,qbh])=
  205 :         int2d(ThBlood)(y*(nuBlood)*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  206 :         +int2d(ThBlood)(gradDiv*(y*(dx(bxh)+dy(byh))+byh)*(y*(dx(vxbh)+dy(vybh))+vybh))
  207 :         +int2d(ThBlood)((1.)*y*terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  208 :         -int2d(ThBlood)((1.)*y*terminePressure(vxbh,vybh,pbh)   (pbh*(dx(vxbh)+dy(vybh)) ) )
  209 :         +int2d(ThBlood)((1./y)*(nuBlood)*byh*vybh)
  210 :         -int2d(ThBlood)((1.)*pbh*vybh)
  211 :         +int2d(ThBlood)((1.)*qbh*byh)
  212 : //      +int1d(ThBlood,4)(1000000000.*[bxh,byh]'*[vxbh,vybh])
  213 :         +on(1,bxh=gBlood,byh=0.)
  214 :         +on(4,bxh=0.,byh=0.)
  215 :         +on(3,byh=0.)
  216 :         ;
  217 :
  218 :
  219 : problem WSSBlood(WSSVal,qbh)=
  220 :         int2d(ThBlood)(y*WSSVal*qbh)
  221 :         +on(4,WSSVal=y*sqrt(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0.
+ tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L -
bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.*
rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)
( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))
  222 :         ;
  223 :
  224 : problem WSSBloodSig(WSSSig,qbh)=
  225 :         int2d(ThBlood)(WSSSig*qbh)
  226 : //      -int1d(ThBlood,4)(WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)*qbh)
  227 : //      +on(4,WSSSig=y*vMaxPar*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)/wssThresh)*WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L))
  228 :         +on(4,WSSSig=WSSSigmoid4(wssThresh,nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)       ( exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)
    [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)
  ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)
  ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)
     ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. +
tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity,
rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x <
.25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*(
L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)
        ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)
 ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))/(1.+exp(-2.5*(sqrt(abs(computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x <
.25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L
- bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )'*computeWSSAxi(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)     ( (nuBlood*stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ) -nuBlood*((stressTensor(bxh,byh)            [[dx(bxh), .5*(dy(bxh)+dx(byh))],[ .5*(dx(byh)+dy(bxh)),dy(byh)]]*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*(
L - bufferZone)) ) ] ))'*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)
  ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] ))*normalVector(tortuosity, rapidity,bufferZone, L)    ( (1./sqrt(1.+funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0.
+ tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) *funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ))*[1.,-funcDeriv(tortuosity, rapidity,bufferZone, L)             ( 0. + tortuosity* rapidity*pi*cos(4.* rapidity*pi*x)*(x>.25*bufferZone && x < .25*( L - bufferZone)) ) ] )  ) )))-wssThresh))) ) )
  229 : //      +on(4,WSSSig=y*(vMaxPar/wssThresh)*(WSSQuickComp(nuBlood,bxh,byh,tortuosity, rapidity,bufferZone, L)))
  230 :         ;
  231 :
  232 : problem nsBlood([bxh,byh,pbh],[vxbh,vybh,qbh])=
  233 :         int2d(ThBlood)(y*(nuBlood)*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  234 :         +int2d(ThBlood)(gradDiv*(y*(dx(bxh)+dy(byh))+byh)*(y*(dx(vxbh)+dy(vybh))+vybh))
  235 :         +int2d(ThBlood)(rhoBlood*y*formaTrilinare(bxLast,byLast,bxh,byh,vxbh,vybh)    (UdotGradU(bxLast,byLast,bxh,byh)     [bxLast*dx(bxh)+byLast*dy(bxh), bxLast*dx(byh) + byLast*dy(byh) ] '*[vxbh,vybh] )  )
  236 :         +int2d(ThBlood)(y*terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  237 :         -int2d(ThBlood)(y*terminePressure(vxbh,vybh,pbh)   (pbh*(dx(vxbh)+dy(vybh)) ) )
  238 :         +int2d(ThBlood)((1./y)*nuBlood*byh*vybh)
  239 :         -int2d(ThBlood)(pbh*vybh)
  240 :         +int2d(ThBlood)(qbh*byh)
  241 : //      +int1d(ThBlood,4)(1000000000.*[bxh,byh]'*[vxbh,vybh])
  242 :         +on(1,bxh=gBlood,byh=0.)
  243 :         +on(4,bxh=0.,byh=0.)
  244 :         +on(3,byh=0.)
  245 :
  246 :         ;
  247 :
  248 : problem nsBloodNewton([bxh,byh,pbh],[vxbh,vybh,qbh])=
  249 :         int2d(ThBlood)(y*nuBlood*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  250 :         +int2d(ThBlood)(gradDiv*(y*(dx(bxh)+dy(byh))+byh)*(y*(dx(vxbh)+dy(vybh))+vybh))
  251 :         +int2d(ThBlood)(rhoBlood*y*formaTrilinare(bxLast,byLast,bxh,byh,vxbh,vybh)    (UdotGradU(bxLast,byLast,bxh,byh)     [bxLast*dx(bxh)+byLast*dy(bxh), bxLast*dx(byh) + byLast*dy(byh) ] '*[vxbh,vybh] )  )
  252 :         +int2d(ThBlood)(rhoBlood*y*formaTrilinare(bxh,byh,bxLast,byLast,vxbh,vybh)    (UdotGradU(bxh,byh,bxLast,byLast)     [bxh*dx(bxLast)+byh*dy(bxLast), bxh*dx(byLast) + byh*dy(byLast) ] '*[vxbh,vybh] )  )
  253 :         -int2d(ThBlood)(rhoBlood*y*formaTrilinare(bxLast,byLast,bxLast,byLast,vxbh,vybh)    (UdotGradU(bxLast,byLast,bxLast,byLast)     [bxLast*dx(bxLast)+byLast*dy(bxLast), bxLast*dx(byLast) + byLast*dy(byLast) ] '*[vxbh,vybh] )  ) 
  254 :         +int2d(ThBlood)(y*terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  255 :         -int2d(ThBlood)(y*terminePressure(vxbh,vybh,pbh)   (pbh*(dx(vxbh)+dy(vybh)) ) )
  256 :         +int2d(ThBlood)((1./y)*nuBlood*byh*vybh)
  257 :         -int2d(ThBlood)(pbh*vybh)
  258 :         +int2d(ThBlood)(qbh*byh)
  259 : //      +int1d(ThBlood,4)(1000000000.*[bxh,byh]'*[vxbh,vybh])
  260 :         +on(1,bxh=gBlood,byh=0.)
  261 :         +on(4,bxh=0.,byh=0.)
  262 :         +on(3,byh=0.)
  263 :
  264 :         ;
  265 :
  266 : problem nsBloodNonCyl([bxh,byh,pbh],[vxbh,vybh,qbh])=
  267 :         int2d(ThBlood)(nuBlood*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  268 :         +int2d(ThBlood)(gradDiv*gradDivStab(bxh,byh,vxbh,vybh)   ( (dx(bxh)+dy(byh))*(dx(vxbh)+dy(vybh)) ) )
  269 :         +int2d(ThBlood)(formaTrilinare(bxLast,byLast,bxh,byh,vxbh,vybh)    (UdotGradU(bxLast,byLast,bxh,byh)
 [bxLast*dx(bxh)+byLast*dy(bxh), bxLast*dx(byh) + byLast*dy(byh) ] '*[vxbh,vybh] )  )
  270 :         +int2d(ThBlood)(terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  271 :         -int2d(ThBlood)(terminePressure(vxbh,vybh,pbh)   (pbh*(dx(vxbh)+dy(vybh)) ) )
  272 :         +on(1,bxh=gBlood,byh=0.)
  273 :         +on(4,bxh=0.,byh=0.);
  274 :
  275 :
  276 : problem nsBloodNewtonNonCyl([bxh,byh,pbh],[vxbh,vybh,qbh])=
  277 :         int2d(ThBlood)(nuBlood*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  278 :         +int2d(ThBlood)(gradDiv*gradDivStab(bxh,byh,vxbh,vybh)   ( (dx(bxh)+dy(byh))*(dx(vxbh)+dy(vybh)) ) )
  279 :         +int2d(ThBlood)(formaTrilinare(bxLast,byLast,bxh,byh,vxbh,vybh)    (UdotGradU(bxLast,byLast,bxh,byh)
 [bxLast*dx(bxh)+byLast*dy(bxh), bxLast*dx(byh) + byLast*dy(byh) ] '*[vxbh,vybh] )  )
  280 :         +int2d(ThBlood)(formaTrilinare(bxh,byh,bxLast,byLast,vxbh,vybh)    (UdotGradU(bxh,byh,bxLast,byLast)
 [bxh*dx(bxLast)+byh*dy(bxLast), bxh*dx(byLast) + byh*dy(byLast) ] '*[vxbh,vybh] )  )
  281 :         -int2d(ThBlood)(formaTrilinare(bxLast,byLast,bxLast,byLast,vxbh,vybh)    (UdotGradU(bxLast,byLast,bxLast,byLast)     [bxLast*dx(bxLast)+byLast*dy(bxLast), bxLast*dx(byLast) + byLast*dy(byLast) ] '*[vxbh,vybh] )  )
  282 :         +int2d(ThBlood)(terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  283 :         -int2d(ThBlood)(terminePressure(vxbh,vybh,pbh)   (pbh*(dx(vxbh)+dy(vybh)) ) )
  284 :         +on(1,bxh=gBlood,byh=0.)
  285 :         +on(4,bxh=0.,byh=0.);
  286 :
  287 : problem stokesBloodNonCyl([bxh,byh,pbh],[vxbh,vybh,qbh])=
  288 :         int2d(ThBlood)(nuBlood*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  289 :         +int2d(ThBlood)(y*gradDiv*gradDivStab(bxh,byh,vxbh,vybh)   ( (dx(bxh)+dy(byh))*(dx(vxbh)+dy(vybh)) ) )
  290 :         +int2d(ThBlood)(terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  291 :         -int2d(ThBlood)(terminePressure(vxbh,vybh,pbh)   (pbh*(dx(vxbh)+dy(vybh)) ) )
  292 :         +on(1,bxh=gBlood,byh=0.)
  293 :         +on(4,bxh=0.,byh=0.);
  294 :
  295 :
  296 :
  297 :
  298 : varf pressurePrecond(pbh,qbh)=
  299 :         int2d(ThBlood)(y*(1./(nuBlood+gradDiv))*pbh*qbh )
  300 : //      +int2d(ThBlood)((1./y)*nuBlood*dy(pbh)*dy(qbh) )
  301 : //      +on(3,pbh=0)
  302 :         ;
  303 :
  304 : varf diffusiveTermBlood([bxh,byh],[vxbh,vybh])=
  305 :         int2d(ThBlood)(y*nuBlood*termineDiffusiva(bxh,byh,vxbh,vybh)  (2*stressTensorDoubleDot(bxh,byh)      [dx(bxh), .5*(dy(bxh)+dx(byh)), .5*(dx(byh)+dy(bxh)),dy(byh) ] '*vectorGradDoubleDot(vxbh,vybh) [dx(vxbh),dy(vxbh),dx(vybh),dy(vybh) ]) )
  306 :         +int2d(ThBlood)(y*gradDiv*gradDivStab(bxh,byh,vxbh,vybh)   ( (dx(bxh)+dy(byh))*(dx(vxbh)+dy(vybh)) ) )
  307 :         +int2d(ThBlood)((1./y)*nuBlood*byh*vybh)
  308 :         +on(1,bxh=gBlood,byh=0.)
  309 :         +on(4,bxh=0.,byh=0.);
  310 :
  311 : varf pressureTermBlood([bxh,byh],[qbh])=
  312 :         int2d(ThBlood)(y*terminePressure(bxh,byh,qbh)   (qbh*(dx(bxh)+dy(byh)) ) )
  313 :         +int2d(ThBlood)(qbh*byh);
  314 :
  315 :
  316 :
  317 : problem stokesDial([dxh,dyh,pdh],[vxdh,vydh,qdh])=
  318 :         int2d(ThDial)(y*(nuDial)*termineDiffusiva(dxh,dyh,vxdh,vydh)  (2*stressTensorDoubleDot(dxh,dyh)      [dx(dxh), .5*(dy(dxh)+dx(dyh)), .5*(dx(dyh)+dy(dxh)),dy(dyh) ] '*vectorGradDoubleDot(vxdh,vydh) [dx(vxdh),dy(vxdh),dx(vydh),dy(vydh) ]) )
  319 :         +int2d(ThDial)(gradDiv*(y*(dx(dxh)+dy(dyh))+dyh)*(y*(dx(vxdh)+dy(vydh))+vydh))
  320 :         //+int2d(ThDial)(gradDiv*gradDivStab(dxh,dyh,vxdh,vydh))
  321 :         +int2d(ThDial)(y*terminePressure(dxh,dyh,qdh)   (qdh*(dx(dxh)+dy(dyh)) ) )
  322 :         -int2d(ThDial)((1.)*y*terminePressure(vxdh,vydh,pdh)   (pdh*(dx(vxdh)+dy(vydh)) ) )
  323 :         +int2d(ThDial)((1./y)*(nuDial)*dyh*vydh)
  324 :         -int2d(ThDial)((1.)*pdh*vydh)
  325 :         +int2d(ThDial)(qdh*dyh)
  326 :         +on(7,dxh=gDial,dyh=0.)
  327 :         +on(6,8,dxh=0.,dyh=0.);
  328 :
  329 :
  330 : problem stokesDialNonCyl([dxh,dyh,pdh],[vxdh,vydh,qdh])=
  331 :         int2d(ThDial)(nuDial*termineDiffusiva(dxh,dyh,vxdh,vydh)  (2*stressTensorDoubleDot(dxh,dyh)      [dx(dxh), .5*(dy(dxh)+dx(dyh)), .5*(dx(dyh)+dy(dxh)),dy(dyh) ] '*vectorGradDoubleDot(vxdh,vydh) [dx(vxdh),dy(vxdh),dx(vydh),dy(vydh) ]) )
  332 :         +int2d(ThDial)(gradDiv*gradDivStab(dxh,dyh,vxdh,vydh)   ( (dx(dxh)+dy(dyh))*(dx(vxdh)+dy(vydh)) ) )
  333 :         +int2d(ThDial)(terminePressure(dxh,dyh,qdh)   (qdh*(dx(dxh)+dy(dyh)) ) )
  334 :         -int2d(ThDial)(terminePressure(vxdh,vydh,pdh)   (pdh*(dx(vxdh)+dy(vydh)) ) )
  335 :
  336 :         +on(7,dxh=gDial,dyh=0.)
  337 :         +on(6,8,dxh=0.,dyh=0.);
  338 :
  339 : problem nsDial([dxh,dyh,pdh],[vxdh,vydh,qdh])=
  340 :         int2d(ThDial)(y*nuDial*termineDiffusiva(dxh,dyh,vxdh,vydh)  (2*stressTensorDoubleDot(dxh,dyh)      [dx(dxh), .5*(dy(dxh)+dx(dyh)), .5*(dx(dyh)+dy(dxh)),dy(dyh) ] '*vectorGradDoubleDot(vxdh,vydh) [dx(vxdh),dy(vxdh),dx(vydh),dy(vydh) ]) )
  341 :         +int2d(ThDial)(gradDiv*(y*(dx(dxh)+dy(dyh))+dyh)*(y*(dx(vxdh)+dy(vydh))+vydh))
  342 :         //+int2d(ThDial)(y*gradDiv*gradDivStab(dxh,dyh,vxdh,vydh))
  343 :         +int2d(ThDial)(rhoDial*y*formaTrilinare(dxLast,dyLast,dxh,dyh,vxdh,vydh)    (UdotGradU(dxLast,dyLast,dxh,dyh)     [dxLast*dx(dxh)+dyLast*dy(dxh), dxLast*dx(dyh) + dyLast*dy(dyh) ] '*[vxdh,vydh] )  )
  344 :         +int2d(ThDial)(y*terminePressure(dxh,dyh,qdh)   (qdh*(dx(dxh)+dy(dyh)) ) )
  345 :         -int2d(ThDial)(y*terminePressure(vxdh,vydh,pdh)   (pdh*(dx(vxdh)+dy(vydh)) ) )
  346 :         +int2d(ThDial)((1./y)*nuDial*dyh*vydh)
  347 :         -int2d(ThDial)(pdh*vydh)
  348 :         +int2d(ThDial)(qdh*dyh)
  349 :         +on(7,dxh=gDial,dyh=0.)
  350 :         +on(6,8,dxh=0.,dyh=0.);
  351 :
  352 :
  353 : problem nsDialNonCyl([dxh,dyh,pdh],[vxdh,vydh,qdh])=
  354 :         int2d(ThDial)(nuDial*termineDiffusiva(dxh,dyh,vxdh,vydh)  (2*stressTensorDoubleDot(dxh,dyh)      [dx(dxh), .5*(dy(dxh)+dx(dyh)), .5*(dx(dyh)+dy(dxh)),dy(dyh) ] '*vectorGradDoubleDot(vxdh,vydh) [dx(vxdh),dy(vxdh),dx(vydh),dy(vydh) ]) )
  355 :         +int2d(ThDial)(y*gradDiv*gradDivStab(dxh,dyh,vxdh,vydh)   ( (dx(dxh)+dy(dyh))*(dx(vxdh)+dy(vydh)) ) )
  356 :         +int2d(ThDial)(formaTrilinare(dxLast,dyLast,dxh,dyh,vxdh,vydh)    (UdotGradU(dxLast,dyLast,dxh,dyh)
[dxLast*dx(dxh)+dyLast*dy(dxh), dxLast*dx(dyh) + dyLast*dy(dyh) ] '*[vxdh,vydh] )  )
  357 :         +int2d(ThDial)(terminePressure(dxh,dyh,qdh)   (qdh*(dx(dxh)+dy(dyh)) ) )
  358 :         -int2d(ThDial)(terminePressure(vxdh,vydh,pdh)   (pdh*(dx(vxdh)+dy(vydh)) ) )
  359 :         +on(7,dxh=gDial,dyh=0.)
  360 :         +on(6,8,dxh=0.,dyh=0.);
  361 :
  362 : problem nsDialNewton([dxh,dyh,pdh],[vxdh,vydh,qdh])=
  363 :         int2d(ThDial)(y*nuDial*termineDiffusiva(dxh,dyh,vxdh,vydh)  (2*stressTensorDoubleDot(dxh,dyh)      [dx(dxh), .5*(dy(dxh)+dx(dyh)), .5*(dx(dyh)+dy(dxh)),dy(dyh) ] '*vectorGradDoubleDot(vxdh,vydh) [dx(vxdh),dy(vxdh),dx(vydh),dy(vydh) ]) )
  364 :         +int2d(ThDial)(gradDiv*(y*(dx(dxh)+dy(dyh))+dyh)*(y*(dx(vxdh)+dy(vydh))+vydh))
  365 :         //+int2d(ThDial)(y*gradDiv*gradDivStab(dxh,dyh,vxdh,vydh))
  366 :         +int2d(ThDial)(rhoDial*y*formaTrilinare(dxLast,dyLast,dxh,dyh,vxdh,vydh)    (UdotGradU(dxLast,dyLast,dxh,dyh)     [dxLast*dx(dxh)+dyLast*dy(dxh), dxLast*dx(dyh) + dyLast*dy(dyh) ] '*[vxdh,vydh] )  )
  367 :         +int2d(ThDial)(rhoDial*y*formaTrilinare(dxh,dyh,dxLast,dyLast,vxdh,vydh)    (UdotGradU(dxh,dyh,dxLast,dyLast)     [dxh*dx(dxLast)+dyh*dy(dxLast), dxh*dx(dyLast) + dyh*dy(dyLast) ] '*[vxdh,vydh] )  )
  368 :         -int2d(ThDial)(rhoDial*y*formaTrilinare(dxLast,dyLast,dxLast,dyLast,vxdh,vydh)    (UdotGradU(dxLast,dyLast,dxLast,dyLast)     [dxLast*dx(dxLast)+dyLast*dy(dxLast), dxLast*dx(dyLast) + dyLast*dy(dyLast) ] '*[vxdh,vydh] )  )
  369 :         +int2d(ThDial)(y*terminePressure(dxh,dyh,qdh)   (qdh*(dx(dxh)+dy(dyh)) ) )
  370 :         -int2d(ThDial)(y*terminePressure(vxdh,vydh,pdh)   (pdh*(dx(vxdh)+dy(vydh)) ) )
  371 :         +int2d(ThDial)((1./y)*nuDial*dyh*vydh)
  372 :         -int2d(ThDial)(pdh*vydh)
  373 :         +int2d(ThDial)(qdh*dyh)
  374 :         +on(7,dxh=gDial,dyh=0.)
  375 :         +on(6,8,dxh=0.,dyh=0.);
  376 :
  377 : problem nsDialNewtonNonCyl([dxh,dyh,pdh],[vxdh,vydh,qdh])=
  378 :         int2d(ThDial)(nuDial*termineDiffusiva(dxh,dyh,vxdh,vydh)  (2*stressTensorDoubleDot(dxh,dyh)      [dx(dxh), .5*(dy(dxh)+dx(dyh)), .5*(dx(dyh)+dy(dxh)),dy(dyh) ] '*vectorGradDoubleDot(vxdh,vydh) [dx(vxdh),dy(vxdh),dx(vydh),dy(vydh) ]) )
  379 :         +int2d(ThDial)(gradDiv*gradDivStab(dxh,dyh,vxdh,vydh)   ( (dx(dxh)+dy(dyh))*(dx(vxdh)+dy(vydh)) ) )
  380 :         +int2d(ThDial)(formaTrilinare(dxLast,dyLast,dxh,dyh,vxdh,vydh)    (UdotGradU(dxLast,dyLast,dxh,dyh)
[dxLast*dx(dxh)+dyLast*dy(dxh), dxLast*dx(dyh) + dyLast*dy(dyh) ] '*[vxdh,vydh] )  )
  381 :         +int2d(ThDial)(formaTrilinare(dxh,dyh,dxLast,dyLast,vxdh,vydh)    (UdotGradU(dxh,dyh,dxLast,dyLast)
[dxh*dx(dxLast)+dyh*dy(dxLast), dxh*dx(dyLast) + dyh*dy(dyLast) ] '*[vxdh,vydh] )  )
  382 :         -int2d(ThDial)(formaTrilinare(dxLast,dyLast,dxLast,dyLast,vxdh,vydh)    (UdotGradU(dxLast,dyLast,dxLast,dyLast)     [dxLast*dx(dxLast)+dyLast*dy(dxLast), dxLast*dx(dyLast) + dyLast*dy(dyLast) ] '*[vxdh,vydh] )  )
  383 :         +int2d(ThDial)(terminePressure(dxh,dyh,qdh)   (qdh*(dx(dxh)+dy(dyh)) ) )
  384 :         -int2d(ThDial)(terminePressure(vxdh,vydh,pdh)   (pdh*(dx(vxdh)+dy(vydh)) ) )
  385 :         +on(7,dxh=gDial,dyh=0.)
  386 :         +on(6,8,dxh=0.,dyh=0.);
  387 :
  388 : string bloodComputed="./computedBlood.txt";
  389 : string dialComputed="./computedDial.txt";
  390 : string bloodPressureComputed="./computedBloodPressure.txt";
  391 : string dialPressureComputed="./computedDialPressure.txt";
  392 : string bloodTransportComputed="./computedBloodTransport.txt";
  393 : string dialTransportComputed="./computedDialTransport.txt";
  394 :
  395 : if(importFlow==true)
  396 : {
  397 :         cout<<"Reading flow solutions..."<<endl;
  398 :         ifstream readBlood(bloodComputed);
  399 :         readBlood >> bxh[];
  400 :         ifstream readDial(dialComputed);
  401 :         readDial >> dxh[];
  402 :         //ifstream readBloodPressure(bloodPressureComputed);
  403 :         //readBloodPressure >> pbh[];
  404 :         //ifstream readDialPressure(dialPressureComputed);
  405 :         //readDialPressure >> pdh[];
  406 : }
  407 : else{
  408 :         cout<<"Computing flow solutions..."<<endl;
  409 :         stokesDial;
  410 :         stokesBlood;
  411 :         dxLast[]=dxh[];
  412 :         bxLast[]=bxh[];
  413 :         real bloodResidual=10.;
  414 :         real dialResidual=10.;
  415 :
  416 :         //linear algebra solves. Not using, hence don't waste time with it, but didn't want to throw the code away.
  417 :         /*
  418 :         matrix Kb=diffusiveTermBlood(VhBlood,VhBlood,solver=UMFPACK);
  419 :         matrix Bb=pressureTermBlood(VhBlood,QhBlood);
  420 :         matrix Mp=pressurePrecond(QhBlood,QhBlood,solver=UMFPACK);
  421 :         matrix Bbt=Bb';
  422 :         Bbt=-Bbt;
  423 :         matrix Ab;
  424 :         matrix Cb;
  425 :         matrix bloodSystem;
  426 :
  427 :         real[int] bloodSol(VhBlood.ndof+QhBlood.ndof);
  428 :         real[int] bloodNSRHSBase(VhBlood.ndof+QhBlood.ndof);
  429 :         real[int] bloodNSRHS(VhBlood.ndof+QhBlood.ndof);
  430 :         bloodNSRHSBase(VhBlood.ndof:(VhBlood.ndof+QhBlood.ndof-1))=0;   1
  431 :         bloodNSRHSBase(0:VhBlood.ndof-1)=diffusiveTermBlood(0,VhBlood);
  432 :
  433 :
  434 :         real[int] tempSolPressure(QhBlood.ndof);
  435 :         real[int] tempSolVelocity(VhBlood.ndof);
  436 :         real[int] velocityRHS(VhBlood.ndof);
  437 :         real[int] pressureRHS(QhBlood.ndof);
  438 :
  439 :         real[int] precondSol(VhBlood.ndof+QhBlood.ndof);
  440 :
  441 :         func real[int] trianglePrecond(real[int]&xx)
  442 :         {
  443 :                 pressureRHS=xx(VhBlood.ndof:(VhBlood.ndof+QhBlood.ndof-1));
  444 :                 tempSolPressure=Mp^-1*pressureRHS;
  445 :                 velocityRHS=Bbt*tempSolPressure;
  446 :                 velocityRHS=-velocityRHS;
  447 :                 velocityRHS+=xx(0:VhBlood.ndof-1);
  448 :                 tempSolVelocity=Kb^-1*velocityRHS;
  449 :
  450 :                 precondSol(0:VhBlood.ndof-1)=tempSolVelocity;
  451 :                 precondSol(VhBlood.ndof:(VhBlood.ndof+QhBlood.ndof-1))=tempSolPressure;
  452 :                 return precondSol;
  453 :
  454 :         }
  455 :
  456 :
  457 :         bloodSystem=[[Kb, Bbt],[Bb, 0]];
  458 :         set(bloodSystem,solver=GMRES, precon=trianglePrecond);
  459 :         bloodSol=bloodSystem^-1*bloodNSRHSBase;
  460 :         bxT[]=bloodSol(0:VhBlood.ndof-1);
  461 :         pbT[]=bloodSol(VhBlood.ndof:(VhBlood.ndof+QhBlood.ndof-1));
  462 :         real DDDD=checkScalarRelativeResidual(pbh,pbT,ThBlood);
  463 :         cout<<"Test "<<DDDD<<endl;
  464 :
  465 :         bloodNSRHS(0:(VhBlood.ndof+QhBlood.ndof-1))=0;
  466 :         */
  467 :         for(int i=0; i<maxIterations; i++)
  468 :         {
  469 :                 if(dialResidual >1e-1 && bloodResidual > 1e-1)
  470 :                         {nsDial; nsBlood; }
  471 :                 else
  472 :                         {nsDialNewton; nsBloodNewton;}
  473 :
  474 :
  475 :                 dialResidual=checkVectorRelativeResidualMesh(dxh,dyh,dxLast,dyLast,ThDial) (checkVectorResidualMesh(dxh,dyh,dxLast,dyLast,ThDial)            ( sqrt( abs( int2d(ThDial)( (dxh-dxLast)^2 + (dyh-dyLast)^2) ) ) ) /vectorNormMesh(dxLast,dyLast,ThDial)      ( sqrt( abs(int2d(ThDial) (dxLast^2+dyLast^2) ) ) ) );
  476 :                 bloodResidual=checkVectorRelativeResidualMesh(bxh,byh,bxLast,byLast,ThBlood) (checkVectorResidualMesh(bxh,byh,bxLast,byLast,ThBlood)            ( sqrt( abs( int2d(ThBlood)( (bxh-bxLast)^2 + (byh-byLast)^2) ) ) ) /vectorNormMesh(bxLast,byLast,ThBlood)      ( sqrt( abs(int2d(ThBlood) (bxLast^2+byLast^2) ) ) ) );
  477 :                 cout<<"Blood residual = "<< bloodResidual<<". Dialysate residual = "<< dialResidual<<"."<<endl;
  478 :                 if((bloodResidual<tolerance) && (dialResidual < tolerance))
  479 :                 {
  480 :                         cout<<"Convergence achieved."<<endl;
  481 :                         break;
  482 :                 }
  483 :                 dxLast[]=dxh[];
  484 :                 bxLast[]=bxh[];
  485 :
  486 :
  487 :                 /*
  488 :                 varf trilinearBloodPicard([bxh,byh],[vxbh,vybh])=
  489 :                         int2d(ThBlood)(y*formaTrilinare(bxLast,byLast,bxh,byh,vxbh,vybh) );
  490 :                 ;
  491 :                         varf trilinearBloodNewton([bxh,byh],[vxbh,vybh])=
  492 :                         int2d(ThBlood)(y*formaTrilinare(bxLast,byLast,bxh,byh,vxbh,vybh) );
  493 :                         +int2d(ThBlood)(y*formaTrilinare(bxh,byh,bxLast,byLast,vxbh,vybh) )
  494 :                 ;
  495 :
  496 :                 varf trilinearBloodRHS([bxh,byh],[vxbh,vybh])=
  497 :                         int2d(ThBlood)(y*formaTrilinare(bxLast,byLast,bxLast,byLast,vxbh,vybh) );
  498 :                 if(bloodResidual > 1e-1)
  499 :                         {Cb=trilinearBloodPicard(VhBlood,VhBlood);}
  500 :                 else
  501 :                 {
  502 :                         Cb=trilinearBloodNewton(VhBlood,VhBlood);
  503 :                         bloodNSRHS(0:VhBlood.ndof-1)=trilinearBloodRHS(0,VhBlood);
  504 :                 }
  505 :                 bloodNSRHS=bloodNSRHS+bloodNSRHSBase;
  506 :                 Ab=Kb+Cb;
  507 :                 set(Ab,solver=UMFPACK);
  508 :                 bloodSystem=[[Ab,Bbt],[Bb,0]];
  509 :                 set(bloodSystem,solver=UMFPACK);//,precon=trianglePrecond);
  510 :                 */
  511 :                 //nsBlood;
  512 :
  513 :                 //bloodNSRHS(0:VhBlood.ndof-1)+=trilinearBloodRHS(0,VhBlood);
  514 :                 //bloodSol=bloodSystem^-1*bloodNSRHS;
  515 :                 //bxh[]=bloodSol(0:VhBlood.ndof-1);
  516 :                 //pbh[]=bloodSol(VhBlood.ndof:(VhBlood.ndof+QhBlood.ndof-1));
  517 :
  518 :         }
  519 :         cout<<"Writing solutions..."<<endl;
  520 :         ofstream writeBlood(bloodComputed);
  521 :         ofstream writeDial(dialComputed);
  522 :         ofstream writeBloodPressure(bloodPressureComputed);
  523 :         ofstream writeDialPressure(dialPressureComputed);
  524 :
  525 :         writeBlood <<bxh[];
  526 :         writeDial << dxh[];
  527 :         writeBloodPressure << pbh[];
  528 :         writeDialPressure << pdh[];
  529 : }
  530 : real bloodFlow=int1d(ThBlood,1)( [bxh,byh]'*[N.x,N.y]*y);
  531 : real dialFlow=int1d(ThDial,7)( [dxh,dyh]'*[N.x,N.y]*y);
  532 : cout<<"Blood flow = "<< bloodFlow <<" ml/s."<<endl;
  533 : cout<<"Dialysate flow = "<< dialFlow <<" ml/s."<<endl;
  534 : WSSBlood;
  535 : WSSBloodSig;
  536 : //exporting outputs.
  537 : vtkVectorVariableExporter(bxWSS,byWSS,"WSS", ThBlood, simResults,"SimTest","WSS",".vtk")
  103 @
  104 @
  105 @
  106 @
  107 @
  108 @
  109 @
  110 @
  111 @
  112 @
  113 @
  114 @
  115 @
  116 @
  117 @
  118 @
  119 @
  120 @
  121 @
  122 @
  123 @
  124 @
  125 @
  126 @
  127 @
  128 @
  129 @
  130 @
  131 @
  132 @
  133 @
  134 @
  135 @
  136 @
  137 @
  138 @
  139 @
  140 @
  141 @
  142 @
  143 @
  144 @
  145 @
  146 @
  147 @
  148 @
  149 @
  150 @
  151 @
  152 @
  153 @
  154 @
  155 @
  156 @
  157 @
  158 @
  159 @
  160 @
  161 @
  162 @
  163 @
  164 @
  165 @
  166 @
  167 @
  168 @
  169 @
  170 @
  171 @
  172 @
  173 @
  174 @
  175 @
  176 @
  177 @
  178 @
  179 @
  180 @
  181 @
  182 @
  183 @
  184 @
  185 @
  186 @
  187 @
  188 @
  189 @
  190 @
  191 @
  192 @
  193 @ {
  103 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","WSS",".vtk")      ( ( (
simResults+"SimTest")+"WSS" ) +".vtk" )  );
  104 @                                 fespace VhC( ThBlood, P2);
  105 @                                 VhC[int] uh(2);
  106 @                                 uh[0] = x;
  107 @                                 uh[1] = y;
  108 @
  109 @
  110 @                                 int nvertices =  ThBlood.nv;
  111 @                                 int ntriangles =  ThBlood.nt;
  112 @                                 int size = VhC.ndof;
  113 @
  114 @
  115 @
  116 @
  117 @
  118 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
  119 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
  120 @                                 fileOutput << "ASCII" << endl;
  121 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
  122 @
  123 @
  124 @
  125 @
  126 @                                 real iter=0;
  127 @                                 fileOutput << "POINTS " << size << " double" << endl;
  128 @                                 for ( int i = 0; i < size; i++)
  129 @                                 {
  130 @                                         real Thx = uh[0][][i];
  131 @                                         real Thy = uh[1][][i];
  132 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
  133 @                                 }
  134 @                                 fileOutput << endl;
  135 @
  136 @
  137 @
  138 @
  139 @
  140 @
  141 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
  142 @                                 for( int i = 0;i<ntriangles; i++)
  143 @                                         {
  144 @                                                 fileOutput << 3 << " ";
  145 @                                                 for(int j = 0; j<3;j++)
  146 @                                                 {
  147 @                                                         fileOutput << VhC(i,j) << " ";
  148 @                                                 }
  149 @                                                 fileOutput << endl;
  150 @                                         }
  151 @
  152 @
  153 @
  154 @
  155 @
  156 @
  157 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
  158 @                                 for(int i=0;i<ntriangles;i++)
  159 @                                 {
  160 @                                         fileOutput << "5 ";
  161 @                                 }
  162 @                                 fileOutput << endl;
  163 @
  164 @
  165 @
  166 @
  167 @
  168 @                                 fileOutput << "POINT_DATA " << size << endl;
  169 @                                 fileOutput << " "<< endl;
  170 @                                 int narray = 1;
  171 @                                 string[int] name(narray);
  172 @                                 name[0] = "WSS" ;
  173 @
  174 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
  175 @
  176 @
  177 @
  178 @                                 fileOutput <<" " << endl;
  179 @                                 fileOutput << name[0] << " 3 " << size <<" double" << endl;
  180 @                                                 for (int i =0; i< size ;i++)
  181 @                                                 {
  182 @
  183 @                                                         real Thx = uh[0][][i];
  184 @                                                         real Thy = uh[1][][i];
  185 @                                                         fileOutput << bxWSS(Thx,Thy) << " "<< byWSS(Thx,Thy) <<" 0"<< endl;
  186 @                                                 }
  187 @
  188 @
  189 @
  190 @
  191 @
  192 @
  193 @ }
  538 : vtkScalarVariableExporter(WSSVal,"WSSVal", ThBlood, simResults,"SimTest","WSSVal",".vtk")
    8 @
    9 @
   10 @
   11 @
   12 @
   13 @
   14 @
   15 @
   16 @
   17 @
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @
   24 @
   25 @
   26 @
   27 @
   28 @
   29 @
   30 @
   31 @
   32 @
   33 @
   34 @
   35 @
   36 @
   37 @
   38 @
   39 @
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @
   47 @
   48 @
   49 @
   50 @
   51 @
   52 @
   53 @
   54 @
   55 @
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @
   63 @
   64 @
   65 @
   66 @
   67 @
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @
   74 @
   75 @
   76 @
   77 @
   78 @
   79 @
   80 @
   81 @
   82 @
   83 @
   84 @
   85 @
   86 @
   87 @
   88 @
   89 @
   90 @
   91 @
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ {
    8 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","WSSVal",".vtk")      ( ( ( simResults+"SimTest")+"WSSVal" ) +".vtk" )  );
    9 @                                 fespace VhC( ThBlood, P2);
   10 @                                 VhC[int] uh(2);
   11 @                                 uh[0] = x;
   12 @                                 uh[1] = y;
   13 @
   14 @
   15 @                                 int nvertices =  ThBlood.nv;
   16 @                                 int ntriangles =  ThBlood.nt;
   17 @                                 int size = VhC.ndof;
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 @                                 fileOutput << "ASCII" << endl;
   26 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 @
   28 @
   29 @
   30 @
   31 @                                 real iter=0;
   32 @                                 fileOutput << "POINTS " << size << " double" << endl;
   33 @                                 for ( int i = 0; i < size; i++)
   34 @                                 {
   35 @                                         real Thx = uh[0][][i];
   36 @                                         real Thy = uh[1][][i];
   37 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 @                                 }
   39 @                                 fileOutput << endl;
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 @                                 for( int i = 0;i<ntriangles; i++)
   48 @                                         {
   49 @                                                 fileOutput << 3 << " ";
   50 @                                                 for(int j = 0; j<3;j++)
   51 @                                                 {
   52 @                                                         fileOutput << VhC(i,j) << " ";
   53 @                                                 }
   54 @                                                 fileOutput << endl;
   55 @                                         }
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 @                                 for(int i=0;i<ntriangles;i++)
   64 @                                 {
   65 @                                         fileOutput << "5 ";
   66 @                                 }
   67 @                                 fileOutput << endl;
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @                                 fileOutput << "POINT_DATA " << size << endl;
   74 @                                 fileOutput << " "<< endl;
   75 @                                 int narray = 1;
   76 @                                 string[int] name(narray);
   77 @                                 name[0] = "WSSVal" ;
   78 @
   79 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 @
   81 @
   82 @
   83 @                                 fileOutput <<" " << endl;
   84 @                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 @                                                 for (int i =0; i< size ;i++)
   86 @                                                 {
   87 @
   88 @                                                         real Thx = uh[0][][i];
   89 @                                                         real Thy = uh[1][][i];
   90 @                                                         fileOutput << WSSVal(Thx,Thy) <<  endl;
   91 @                                                 }
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ }
  539 : vtkScalarVariableExporter(WSSSig,"WSSSig", ThBlood, simResults,"SimTest","WSSSig",".vtk")
    8 @
    9 @
   10 @
   11 @
   12 @
   13 @
   14 @
   15 @
   16 @
   17 @
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @
   24 @
   25 @
   26 @
   27 @
   28 @
   29 @
   30 @
   31 @
   32 @
   33 @
   34 @
   35 @
   36 @
   37 @
   38 @
   39 @
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @
   47 @
   48 @
   49 @
   50 @
   51 @
   52 @
   53 @
   54 @
   55 @
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @
   63 @
   64 @
   65 @
   66 @
   67 @
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @
   74 @
   75 @
   76 @
   77 @
   78 @
   79 @
   80 @
   81 @
   82 @
   83 @
   84 @
   85 @
   86 @
   87 @
   88 @
   89 @
   90 @
   91 @
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ {
    8 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","WSSSig",".vtk")      ( ( ( simResults+"SimTest")+"WSSSig" ) +".vtk" )  );
    9 @                                 fespace VhC( ThBlood, P2);
   10 @                                 VhC[int] uh(2);
   11 @                                 uh[0] = x;
   12 @                                 uh[1] = y;
   13 @
   14 @
   15 @                                 int nvertices =  ThBlood.nv;
   16 @                                 int ntriangles =  ThBlood.nt;
   17 @                                 int size = VhC.ndof;
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 @                                 fileOutput << "ASCII" << endl;
   26 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 @
   28 @
   29 @
   30 @
   31 @                                 real iter=0;
   32 @                                 fileOutput << "POINTS " << size << " double" << endl;
   33 @                                 for ( int i = 0; i < size; i++)
   34 @                                 {
   35 @                                         real Thx = uh[0][][i];
   36 @                                         real Thy = uh[1][][i];
   37 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 @                                 }
   39 @                                 fileOutput << endl;
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 @                                 for( int i = 0;i<ntriangles; i++)
   48 @                                         {
   49 @                                                 fileOutput << 3 << " ";
   50 @                                                 for(int j = 0; j<3;j++)
   51 @                                                 {
   52 @                                                         fileOutput << VhC(i,j) << " ";
   53 @                                                 }
   54 @                                                 fileOutput << endl;
   55 @                                         }
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 @                                 for(int i=0;i<ntriangles;i++)
   64 @                                 {
   65 @                                         fileOutput << "5 ";
   66 @                                 }
   67 @                                 fileOutput << endl;
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @                                 fileOutput << "POINT_DATA " << size << endl;
   74 @                                 fileOutput << " "<< endl;
   75 @                                 int narray = 1;
   76 @                                 string[int] name(narray);
   77 @                                 name[0] = "WSSSig" ;
   78 @
   79 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 @
   81 @
   82 @
   83 @                                 fileOutput <<" " << endl;
   84 @                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 @                                                 for (int i =0; i< size ;i++)
   86 @                                                 {
   87 @
   88 @                                                         real Thx = uh[0][][i];
   89 @                                                         real Thy = uh[1][][i];
   90 @                                                         fileOutput << WSSSig(Thx,Thy) <<  endl;
   91 @                                                 }
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ }
  540 : vtkVectorVariableExporter(bxh,byh,"Blood", ThBlood, simResults,"SimTest","blood",".vtk")
  103 @
  104 @
  105 @
  106 @
  107 @
  108 @
  109 @
  110 @
  111 @
  112 @
  113 @
  114 @
  115 @
  116 @
  117 @
  118 @
  119 @
  120 @
  121 @
  122 @
  123 @
  124 @
  125 @
  126 @
  127 @
  128 @
  129 @
  130 @
  131 @
  132 @
  133 @
  134 @
  135 @
  136 @
  137 @
  138 @
  139 @
  140 @
  141 @
  142 @
  143 @
  144 @
  145 @
  146 @
  147 @
  148 @
  149 @
  150 @
  151 @
  152 @
  153 @
  154 @
  155 @
  156 @
  157 @
  158 @
  159 @
  160 @
  161 @
  162 @
  163 @
  164 @
  165 @
  166 @
  167 @
  168 @
  169 @
  170 @
  171 @
  172 @
  173 @
  174 @
  175 @
  176 @
  177 @
  178 @
  179 @
  180 @
  181 @
  182 @
  183 @
  184 @
  185 @
  186 @
  187 @
  188 @
  189 @
  190 @
  191 @
  192 @
  193 @ {
  103 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","blood",".vtk")      ( (
( simResults+"SimTest")+"blood" ) +".vtk" )  );
  104 @                                 fespace VhC( ThBlood, P2);
  105 @                                 VhC[int] uh(2);
  106 @                                 uh[0] = x;
  107 @                                 uh[1] = y;
  108 @
  109 @
  110 @                                 int nvertices =  ThBlood.nv;
  111 @                                 int ntriangles =  ThBlood.nt;
  112 @                                 int size = VhC.ndof;
  113 @
  114 @
  115 @
  116 @
  117 @
  118 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
  119 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
  120 @                                 fileOutput << "ASCII" << endl;
  121 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
  122 @
  123 @
  124 @
  125 @
  126 @                                 real iter=0;
  127 @                                 fileOutput << "POINTS " << size << " double" << endl;
  128 @                                 for ( int i = 0; i < size; i++)
  129 @                                 {
  130 @                                         real Thx = uh[0][][i];
  131 @                                         real Thy = uh[1][][i];
  132 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
  133 @                                 }
  134 @                                 fileOutput << endl;
  135 @
  136 @
  137 @
  138 @
  139 @
  140 @
  141 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
  142 @                                 for( int i = 0;i<ntriangles; i++)
  143 @                                         {
  144 @                                                 fileOutput << 3 << " ";
  145 @                                                 for(int j = 0; j<3;j++)
  146 @                                                 {
  147 @                                                         fileOutput << VhC(i,j) << " ";
  148 @                                                 }
  149 @                                                 fileOutput << endl;
  150 @                                         }
  151 @
  152 @
  153 @
  154 @
  155 @
  156 @
  157 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
  158 @                                 for(int i=0;i<ntriangles;i++)
  159 @                                 {
  160 @                                         fileOutput << "5 ";
  161 @                                 }
  162 @                                 fileOutput << endl;
  163 @
  164 @
  165 @
  166 @
  167 @
  168 @                                 fileOutput << "POINT_DATA " << size << endl;
  169 @                                 fileOutput << " "<< endl;
  170 @                                 int narray = 1;
  171 @                                 string[int] name(narray);
  172 @                                 name[0] = "Blood" ;
  173 @
  174 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
  175 @
  176 @
  177 @
  178 @                                 fileOutput <<" " << endl;
  179 @                                 fileOutput << name[0] << " 3 " << size <<" double" << endl;
  180 @                                                 for (int i =0; i< size ;i++)
  181 @                                                 {
  182 @
  183 @                                                         real Thx = uh[0][][i];
  184 @                                                         real Thy = uh[1][][i];
  185 @                                                         fileOutput << bxh(Thx,Thy) << " "<< byh(Thx,Thy) <<" 0"<< endl;
  186 @                                                 }
  187 @
  188 @
  189 @
  190 @
  191 @
  192 @
  193 @ }
  541 : vtkScalarVariableExporter(pbh,"BloodPressure", ThBlood, simResults,"SimTest","bloodpressure",".vtk")
    8 @
    9 @
   10 @
   11 @
   12 @
   13 @
   14 @
   15 @
   16 @
   17 @
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @
   24 @
   25 @
   26 @
   27 @
   28 @
   29 @
   30 @
   31 @
   32 @
   33 @
   34 @
   35 @
   36 @
   37 @
   38 @
   39 @
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @
   47 @
   48 @
   49 @
   50 @
   51 @
   52 @
   53 @
   54 @
   55 @
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @
   63 @
   64 @
   65 @
   66 @
   67 @
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @
   74 @
   75 @
   76 @
   77 @
   78 @
   79 @
   80 @
   81 @
   82 @
   83 @
   84 @
   85 @
   86 @
   87 @
   88 @
   89 @
   90 @
   91 @
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ {
    8 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","bloodpressure",".vtk")
    ( ( ( simResults+"SimTest")+"bloodpressure" ) +".vtk" )  );
    9 @                                 fespace VhC( ThBlood, P2);
   10 @                                 VhC[int] uh(2);
   11 @                                 uh[0] = x;
   12 @                                 uh[1] = y;
   13 @
   14 @
   15 @                                 int nvertices =  ThBlood.nv;
   16 @                                 int ntriangles =  ThBlood.nt;
   17 @                                 int size = VhC.ndof;
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 @                                 fileOutput << "ASCII" << endl;
   26 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 @
   28 @
   29 @
   30 @
   31 @                                 real iter=0;
   32 @                                 fileOutput << "POINTS " << size << " double" << endl;
   33 @                                 for ( int i = 0; i < size; i++)
   34 @                                 {
   35 @                                         real Thx = uh[0][][i];
   36 @                                         real Thy = uh[1][][i];
   37 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 @                                 }
   39 @                                 fileOutput << endl;
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 @                                 for( int i = 0;i<ntriangles; i++)
   48 @                                         {
   49 @                                                 fileOutput << 3 << " ";
   50 @                                                 for(int j = 0; j<3;j++)
   51 @                                                 {
   52 @                                                         fileOutput << VhC(i,j) << " ";
   53 @                                                 }
   54 @                                                 fileOutput << endl;
   55 @                                         }
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 @                                 for(int i=0;i<ntriangles;i++)
   64 @                                 {
   65 @                                         fileOutput << "5 ";
   66 @                                 }
   67 @                                 fileOutput << endl;
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @                                 fileOutput << "POINT_DATA " << size << endl;
   74 @                                 fileOutput << " "<< endl;
   75 @                                 int narray = 1;
   76 @                                 string[int] name(narray);
   77 @                                 name[0] = "BloodPressure" ;
   78 @
   79 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 @
   81 @
   82 @
   83 @                                 fileOutput <<" " << endl;
   84 @                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 @                                                 for (int i =0; i< size ;i++)
   86 @                                                 {
   87 @
   88 @                                                         real Thx = uh[0][][i];
   89 @                                                         real Thy = uh[1][][i];
   90 @                                                         fileOutput << pbh(Thx,Thy) <<  endl;
   91 @                                                 }
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ }
  542 : vtkVectorVariableExporter(dxh,dyh,"Dial", ThDial, simResults,"SimTest","dial",".vtk")
  103 @
  104 @
  105 @
  106 @
  107 @
  108 @
  109 @
  110 @
  111 @
  112 @
  113 @
  114 @
  115 @
  116 @
  117 @
  118 @
  119 @
  120 @
  121 @
  122 @
  123 @
  124 @
  125 @
  126 @
  127 @
  128 @
  129 @
  130 @
  131 @
  132 @
  133 @
  134 @
  135 @
  136 @
  137 @
  138 @
  139 @
  140 @
  141 @
  142 @
  143 @
  144 @
  145 @
  146 @
  147 @
  148 @
  149 @
  150 @
  151 @
  152 @
  153 @
  154 @
  155 @
  156 @
  157 @
  158 @
  159 @
  160 @
  161 @
  162 @
  163 @
  164 @
  165 @
  166 @
  167 @
  168 @
  169 @
  170 @
  171 @
  172 @
  173 @
  174 @
  175 @
  176 @
  177 @
  178 @
  179 @
  180 @
  181 @
  182 @
  183 @
  184 @
  185 @
  186 @
  187 @
  188 @
  189 @
  190 @
  191 @
  192 @
  193 @ {
  103 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","dial",".vtk")      ( ( ( simResults+"SimTest")+"dial" ) +".vtk" )  );
  104 @                                 fespace VhC( ThDial, P2);
  105 @                                 VhC[int] uh(2);
  106 @                                 uh[0] = x;
  107 @                                 uh[1] = y;
  108 @
  109 @
  110 @                                 int nvertices =  ThDial.nv;
  111 @                                 int ntriangles =  ThDial.nt;
  112 @                                 int size = VhC.ndof;
  113 @
  114 @
  115 @
  116 @
  117 @
  118 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
  119 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
  120 @                                 fileOutput << "ASCII" << endl;
  121 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
  122 @
  123 @
  124 @
  125 @
  126 @                                 real iter=0;
  127 @                                 fileOutput << "POINTS " << size << " double" << endl;
  128 @                                 for ( int i = 0; i < size; i++)
  129 @                                 {
  130 @                                         real Thx = uh[0][][i];
  131 @                                         real Thy = uh[1][][i];
  132 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
  133 @                                 }
  134 @                                 fileOutput << endl;
  135 @
  136 @
  137 @
  138 @
  139 @
  140 @
  141 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
  142 @                                 for( int i = 0;i<ntriangles; i++)
  143 @                                         {
  144 @                                                 fileOutput << 3 << " ";
  145 @                                                 for(int j = 0; j<3;j++)
  146 @                                                 {
  147 @                                                         fileOutput << VhC(i,j) << " ";
  148 @                                                 }
  149 @                                                 fileOutput << endl;
  150 @                                         }
  151 @
  152 @
  153 @
  154 @
  155 @
  156 @
  157 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
  158 @                                 for(int i=0;i<ntriangles;i++)
  159 @                                 {
  160 @                                         fileOutput << "5 ";
  161 @                                 }
  162 @                                 fileOutput << endl;
  163 @
  164 @
  165 @
  166 @
  167 @
  168 @                                 fileOutput << "POINT_DATA " << size << endl;
  169 @                                 fileOutput << " "<< endl;
  170 @                                 int narray = 1;
  171 @                                 string[int] name(narray);
  172 @                                 name[0] = "Dial" ;
  173 @
  174 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
  175 @
  176 @
  177 @
  178 @                                 fileOutput <<" " << endl;
  179 @                                 fileOutput << name[0] << " 3 " << size <<" double" << endl;
  180 @                                                 for (int i =0; i< size ;i++)
  181 @                                                 {
  182 @
  183 @                                                         real Thx = uh[0][][i];
  184 @                                                         real Thy = uh[1][][i];
  185 @                                                         fileOutput << dxh(Thx,Thy) << " "<< dyh(Thx,Thy) <<" 0"<< endl;
  186 @                                                 }
  187 @
  188 @
  189 @
  190 @
  191 @
  192 @
  193 @ }
  543 : vtkScalarVariableExporter(pdh,"DialPressure", ThDial, simResults,"SimTest","dialpressure",".vtk")
    8 @
    9 @
   10 @
   11 @
   12 @
   13 @
   14 @
   15 @
   16 @
   17 @
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @
   24 @
   25 @
   26 @
   27 @
   28 @
   29 @
   30 @
   31 @
   32 @
   33 @
   34 @
   35 @
   36 @
   37 @
   38 @
   39 @
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @
   47 @
   48 @
   49 @
   50 @
   51 @
   52 @
   53 @
   54 @
   55 @
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @
   63 @
   64 @
   65 @
   66 @
   67 @
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @
   74 @
   75 @
   76 @
   77 @
   78 @
   79 @
   80 @
   81 @
   82 @
   83 @
   84 @
   85 @
   86 @
   87 @
   88 @
   89 @
   90 @
   91 @
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ {
    8 @                                 ofstream fileOutput(variablePath( simResults,"SimTest","dialpressure",".vtk")
   ( ( ( simResults+"SimTest")+"dialpressure" ) +".vtk" )  );
    9 @                                 fespace VhC( ThDial, P2);
   10 @                                 VhC[int] uh(2);
   11 @                                 uh[0] = x;
   12 @                                 uh[1] = y;
   13 @
   14 @
   15 @                                 int nvertices =  ThDial.nv;
   16 @                                 int ntriangles =  ThDial.nt;
   17 @                                 int size = VhC.ndof;
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 @                                 fileOutput << "ASCII" << endl;
   26 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 @
   28 @
   29 @
   30 @
   31 @                                 real iter=0;
   32 @                                 fileOutput << "POINTS " << size << " double" << endl;
   33 @                                 for ( int i = 0; i < size; i++)
   34 @                                 {
   35 @                                         real Thx = uh[0][][i];
   36 @                                         real Thy = uh[1][][i];
   37 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 @                                 }
   39 @                                 fileOutput << endl;
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 @                                 for( int i = 0;i<ntriangles; i++)
   48 @                                         {
   49 @                                                 fileOutput << 3 << " ";
   50 @                                                 for(int j = 0; j<3;j++)
   51 @                                                 {
   52 @                                                         fileOutput << VhC(i,j) << " ";
   53 @                                                 }
   54 @                                                 fileOutput << endl;
   55 @                                         }
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 @                                 for(int i=0;i<ntriangles;i++)
   64 @                                 {
   65 @                                         fileOutput << "5 ";
   66 @                                 }
   67 @                                 fileOutput << endl;
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @                                 fileOutput << "POINT_DATA " << size << endl;
   74 @                                 fileOutput << " "<< endl;
   75 @                                 int narray = 1;
   76 @                                 string[int] name(narray);
   77 @                                 name[0] = "DialPressure" ;
   78 @
   79 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 @
   81 @
   82 @
   83 @                                 fileOutput <<" " << endl;
   84 @                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 @                                                 for (int i =0; i< size ;i++)
   86 @                                                 {
   87 @
   88 @                                                         real Thx = uh[0][][i];
   89 @                                                         real Thy = uh[1][][i];
   90 @                                                         fileOutput << pdh(Thx,Thy) <<  endl;
   91 @                                                 }
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ }
  544 : cbhOld[]=cbhLast[];
  545 : cdhOld[]=cdhLast[];
  546 : //real origBalance=int2d(ThBlood)(cbhLast);
  547 : real[int] bloodRHS(QhBlood.ndof);
  548 : real[int] dialRHS(QhDial.ndof);
  549 : matrix KBlood=bloodBEVarf(QhBlood,QhBlood,solver=UMFPACK);
  550 : bloodRHS=bloodBERHS(0,QhBlood);
  551 : bloodRHS+=bloodBEVarf(0,QhBlood);
  552 : matrix KDial=dialysateBEVarf(QhDial,QhDial,solver=UMFPACK);
  553 : dialRHS=dialysateBERHS(0,QhDial);
  554 : dialRHS+=dialysateBEVarf(0,QhDial);
  555 : real clearance;
  556 : //this solves the transport equations by forming the system
  557 : //where b is blood, d is dialysate:
  558 : // [A_b B_bd^T] [b] = [f_b]
  559 : // [B_bd A_d ]  [d] = [f_d]
  560 : // and solving monolithically.
  561 : matrix matricone;
  562 : real bloodIn, bloodOut, dialIn, dialOut, imbalance,monolithicTime;
  563 : if(transportSolverType=="monolithic")
  564 : {
  565 :
  566 :         monolithicTime=clock();
  567 :         cout<<"Solving transport equations monolithically."<<endl;
  568 :         matrix coupling=bloodBERHSMat(QhBlood,QhDial);
  569 :         matrix couplingT=coupling';
  570 :         real[int] fullSysRHS(QhDial.ndof+QhBlood.ndof);
  571 :         real[int] fullSysSol(QhDial.ndof+QhBlood.ndof);
  572 :         fullSysRHS(0:QhDial.ndof-1)=dialysateBEVarf(0,QhDial);
  573 :         fullSysRHS(QhDial.ndof:(QhDial.ndof+QhBlood.ndof-1))=bloodBEVarf(0,QhBlood);
  574 :         real[int] precondBloodRHS(QhBlood.ndof);
  575 :         real[int] precondDialRHS(QhDial.ndof);
  576 :         real[int] precondBloodSol(QhBlood.ndof);
  577 :         real[int] precondDialSol(QhDial.ndof);
  578 :         real[int] precondFullSol(QhBlood.ndof+QhDial.ndof);
  579 :
  580 :         func real[int] blockGSPrecond(real[int]&xx)
  581 :         {
  582 :                 precondBloodRHS=xx(QhDial.ndof:(QhBlood.ndof+QhDial.ndof-1));
  583 :                 precondBloodSol=KBlood^-1*precondBloodRHS;
  584 :                 precondDialRHS=coupling*precondBloodSol;
  585 :                 precondDialRHS=-precondDialRHS;
  586 :                 precondDialRHS=precondDialRHS+xx(0:QhDial.ndof-1);
  587 :                 precondDialSol=KDial^-1*precondDialRHS;
  588 :                 precondFullSol(0:QhDial.ndof-1)=precondDialSol;
  589 :                 precondFullSol(QhDial.ndof:(QhDial.ndof+QhBlood.ndof-1))=precondBloodSol;
  590 :                 return precondFullSol;
  591 :         }
  592 :
  593 :         func real[int] blockJacobiPrecond(real[int]&xx)
  594 :         {
  595 :                 precondBloodRHS=xx(QhDial.ndof:(QhBlood.ndof+QhDial.ndof-1));
  596 :                 precondDialRHS=xx(0:QhDial.ndof-1);
  597 :                 precondBloodSol=KBlood^-1*precondBloodRHS;
  598 :                 precondDialSol=KDial^-1*precondDialRHS;
  599 :                 precondFullSol(0:QhDial.ndof-1)=precondDialSol;
  600 :                 precondFullSol(QhDial.ndof:(QhDial.ndof+QhBlood.ndof-1))=precondBloodSol;
  601 :                 return precondFullSol;
  602 :         }
  603 :
  604 :
  605 :         matricone=[[KDial, coupling],[couplingT,KBlood]];
  606 : //      set(matricone,solver=UMFPACK);
  607 :         if(transportPreconditioner=="gauss-seidel")
  608 :         {
  609 :                 cout<<"Solving with Gauss-Seidel preconditioned GMRES."<<endl;
  610 :                 set(matricone,solver=GMRES,precon=blockGSPrecond);
  611 :         }
  612 :         else if(transportPreconditioner=="jacobi")
  613 :         {
  614 :                 cout<<"Solving with Jacobi preconditioned GMRES."<<endl;
  615 :                 set(matricone,solver=GMRES,precon=blockJacobiPrecond);
  616 :         }
  617 :         else
  618 :         {
  619 :                 cout<<"Solving directly."<<endl;
  620 :                 set(matricone,solver=UMFPACK);
  621 :         }
  622 :         fullSysSol=matricone^-1*fullSysRHS;
  623 :         cdh[]=fullSysSol(0:QhDial.ndof-1);
  624 :         cbh[]=fullSysSol(QhDial.ndof:(QhDial.ndof+QhBlood.ndof-1));
  625 :
  626 :         bloodIn=abs(int1d(ThBlood,1)(y*cbh*[bxh,byh]'*[N.x,N.y]));
  627 :         bloodOut=abs(int1d(ThBlood,3)(y*cbh*[bxh,byh]'*[N.x,N.y]));
  628 :         dialIn=abs(int1d(ThDial,7)(y*cdh*[dxh,dyh]'*[N.x,N.y]));
  629 :         dialOut=abs(int1d(ThDial,5)(y*cdh*[dxh,dyh]'*[N.x,N.y]));
  630 :         imbalance= abs((bloodIn+dialIn)-(dialOut+bloodOut))/(bloodIn+dialIn);
  631 :         clearance = 2.*pi*bloodFlow*(dialOut)/bloodIn;
  632 :         cout<<"Blood in = "<< bloodIn <<". Blood out = "<< bloodOut <<". Dial in = "<< dialIn <<". Dial out = "<<dialOut<<". Imbalance residual= "<<imbalance <<"."<< endl;
  633 :         cout<<"Clearance = "<<clearance<<"."<<endl;
  634 :         monolithicTime=clock()-monolithicTime;
  635 :         cout<<"Time: "<<monolithicTime<<" seconds."<<endl;
  636 : }
  637 :
  638 : else{
  639 :         real iterativeTime=clock();
  640 :         cbh[]=KBlood^-1*bloodRHS;
  641 :         cdh[]=KDial^-1*dialRHS;
  642 :         matrix coupling=bloodBERHSMat(QhBlood,QhDial);
  643 :         matrix couplingT=coupling';
  644 :         cdhLast[]=cdh[];
  645 :         cbhLast[]=cbh[];
  646 :         cbhOld[]=cbhLast[];
  647 :         cdhOld[]=cdhLast[];
  648 :
  649 :         real origBalance=int2d(ThBlood)(cbhLast)+int2d(ThDial)(cdhLast);
  650 :
  651 :         matricone=[[KDial, coupling],[couplingT,KBlood]];
  652 :
  653 :         real currentTime;
  654 :         real bloodBalance;
  655 :         real dialBalance;
  656 :         real massLoss;
  657 :         real fullBalance;
  658 :         real imbalance;
  659 :         real residBlood=10.;
  660 :         real residDial=10.;
  661 :         real residCheck;
  662 :         real[int]bloodRHSBase=bloodBEVarf(0,QhBlood);
  663 :         real[int]dialRHSBase=dialysateBEVarf(0,QhDial);
  664 :         real[int]fullRHSVector(QhBlood.ndof+QhDial.ndof);
  665 :         real[int]fullSolVector(QhBlood.ndof+QhDial.ndof);
  666 :         real[int]fullResidVector(QhBlood.ndof+QhDial.ndof);
  667 :         fullRHSVector(0:QhDial.ndof-1)=dialRHSBase;
  668 :         fullRHSVector(QhDial.ndof:(QhDial.ndof+QhBlood.ndof-1))=bloodRHSBase;
  669 :
  670 :         for(int i=0; i<numStepsMix;i++)
  671 :         {
  672 :                 cout<<"Iteration " << i <<"."<<endl;
  673 :                 currentTime=i*dt;
  674 :
  675 :                 //bloodRHS=bloodBEVarf(0,QhBlood);
  676 :                 //dialRHS=dialysateBEVarf(0,QhDial);
  677 :                 if(transportSolverType=="jacobi")
  678 :                 {
  679 :                         cout<<"Solving transport equations with Jacobi iteration
  ... : s..."<<endl;
  680 : //                      bloodRHS=bloodRHSBase;
  681 : //                      bloodRHS+=couplingT*cdhOld[];
  682 :                         bloodRHS=couplingT*cdhOld[];
  683 :                         bloodRHS=-1*bloodRHS;
  684 :                         bloodRHS=bloodRHS+bloodRHSBase;
  685 : //                      dialRHS=dialRHSBase;
  686 :                         dialRHS=coupling*cbh[];
  687 :                         dialRHS=-dialRHS;
  688 :                         dialRHS=dialRHS+dialRHSBase;
  689 : //                      dialRHS+=coupling*cbhOld[];
  690 :                         cdh[]=KDial^-1*dialRHS;
  691 :                         cbh[]=KBlood^-1*bloodRHS;
  692 :                 }
  693 :                 else
  694 :                 {
  695 :                         if(transportSolverType=="gauss-seidel")
  696 :                                 {cout<<"Solving transport equations with Gauss-Seidel ite
  ... : rations..."<<endl;}
  697 :                         else
  698 :                                 {cout<<"Transport solver definition not recognized. Defau
  ... : lting to Gauss-Seidel solve."<<endl;}
  699 :                         //bloodRHS+=bloodBERHS(0,QhBlood);
  700 :                         bloodRHS=couplingT*cdhOld[];
  701 :                         bloodRHS=-1*bloodRHS;
  702 :                         bloodRHS=bloodRHS+bloodRHSBase;
  703 :                         //bloodRHS=bloodRHS-couplingT*cdhOld[];
  704 :                 //dialRHS=dialRHS+dialRHSBase;
  705 :                         cbh[]=KBlood^-1*bloodRHS;
  706 :                         dialRHS=coupling*cbh[];
  707 :                         dialRHS=-dialRHS;
  708 :                         dialRHS=dialRHS+dialRHSBase;//-coupling*cbh[];//dialysateBERHS(0,QhDial);
  709 :                         cdh[]=KDial^-1*dialRHS;
  710 :                 }
  711 :
  712 :                 for(int j=0;j<subIterations;j++)
  713 :                 {
  714 :                         bloodRHS=bloodBERHS(0,QhBlood);
  715 :                         dialRHS=dialysateBERHS(0,QhDial);
  716 :                         cbh[]=KBlood^-1*bloodRHS;
  717 :                         cdh[]=KDial^-1*dialRHS;
  718 :                         cbhOld[]=cbh[];
  719 :                         cdhOld[]=cdh[];
  720 :                         massLoss=int1d(ThDial,5)( .2*(cdhOld*nuDial-nuBlood*cbhOld))+int1d(ThBlood,3)( .2*(cbhOld*nuBlood-nuDial*cdhOld));
  721 :                         cout<<"Mass loss = "<<massLoss<<"."<<endl;
  722 :                 }
  723 :
  724 :                 //bloodBalance=int2d(ThBlood)(cbh);
  725 :                 //dialBalance=int2d(ThDial)(cdh);
  726 :                 //fullBalance=bloodBalance+dialBalance;
  727 :                 //ofstream risultati(outputFile,append);
  728 :                 //risultati<<currentTime<<"     "<<bloodBalance<<"      "<<dialBalance<<"       "<<fullBalance<<"       "<<fullBalance/origBalance<<endl;
  729 :                 //cout<<currentTime<<"  "<<bloodBalance<<"      "<<dialBalance<<"       "<<fullBalance<<"
"<<fullBalance/origBalance<<endl;
  730 :
  731 :                 bloodIn=abs(int1d(ThBlood,1)(y*cbh*[bxh,byh]'*[N.x,N.y]));
  732 :                 bloodOut=abs(int1d(ThBlood,3)(y*cbh*[bxh,byh]'*[N.x,N.y]));
  733 :                 dialIn=abs(int1d(ThDial,7)(y*cdh*[dxh,dyh]'*[N.x,N.y]));
  734 :                 dialOut=abs(int1d(ThDial,5)(y*cdh*[dxh,dyh]'*[N.x,N.y]));
  735 :                 fullSolVector(0:QhDial.ndof-1)=cdh[];
  736 :                 fullSolVector(QhDial.ndof:(QhDial.ndof+QhBlood.ndof-1))=cbh[];
  737 :
  738 :
  739 :                 fullResidVector=matricone*fullSolVector;
  740 :                 fullResidVector=-fullResidVector;
  741 :                 fullResidVector=fullResidVector+fullRHSVector;
  742 :                 residCheck=sqrt(fullResidVector'*fullResidVector);
  743 :                 //residCheck=checkScalarResidual(cdh,cdhOld,ThDial)+checkScalarResidual(cbh,cbhOld,ThBlood);
  744 :
  745 :                 cdhLast[]=cdh[];
  746 :                 cbhLast[]=cbh[];
  747 :                 cbhOld[]=cbh[];
  748 :                 cdhOld[]=cdh[];
  749 :
  750 :                 imbalance= abs((bloodIn+dialIn)-(dialOut+bloodOut))/(bloodIn+dialIn);
  751 :                 clearance = 2.*pi*bloodFlow*(dialOut)/bloodIn;
  752 :                 cout<<"Blood in = "<< bloodIn <<". Blood out = "<< bloodOut <<". Dial in = "<< dialIn <<". Dial
out = "<<dialOut<<". Imbalance residual= "<<imbalance <<"."<< endl;
  753 :                 cout<<"Residual = "<< residCheck<<"."<<endl;
  754 :                 cout<<"Clearance = "<<clearance<<"."<<endl;
  755 :
  756 :                 if(residCheck<transportTol)
  757 :                 {
  758 :                         iterativeTime=clock()-iterativeTime;
  759 :                         cout<<"Convergence achieved in: "<<i<<" iterations. Time: "<<iterativeTime <<" seconds."<<endl;
  760 :                         //cout<<checkScalarResidual(cdh,cdhLast2,ThDial)<<endl;
  761 :
  762 :                         string gridConvFile;//="/Users/alexviguerie/Documents/MATLAB/Dialisi/Grid_Convergence/"; 
  763 :                         gridConvFile=directory+meshAppend;
  764 :                         ofstream gridDataOut(gridConvFile,append);
  765 :                         real bloodMeshSize=0;
  766 :                         real dialMeshSize=0;
  767 :                         for(int i=0; i<hBlood.n ; i++)
  768 :                                 {bloodMeshSize=bloodMeshSize+hBlood[](i);}
  769 :                         for(int i=0; i<hDial.n ; i++)
  770 :                                 {dialMeshSize=dialMeshSize+hDial[](i);}
  771 :                         bloodMeshSize=bloodMeshSize/hBlood.n;
  772 :                         dialMeshSize=dialMeshSize/hDial.n;
  773 :
  774 :
  775 :                         gridDataOut <<n<<"      "<<QhBlood.ndof+QhDial.ndof<<"  "<<bloodMeshSize<<"     "<<dialMeshSize<<"      "<<"    "<<2.*wssThresh<<"      "<<rapidity<<"  "<<tortuosity <<"       "<<bloodIn<<"   "<<bloodOut<<"
"<<dialIn<<"    "<<dialOut<<"   "<<clearance<<" "<<i<<" "<<iterativeTime<<endl;
  776 :                         cout <<n<<"     "<<QhBlood.ndof+QhDial.ndof<<"  "<<bloodMeshSize<<"     "<<dialMeshSize<<"      "<<2.*wssThresh<<"      "<<rapidity<<"  "<<tortuosity <<"       "<<bloodIn<<"   "<<bloodOut<<"  "<<dialIn<<"
"<<dialOut<<"   "<<clearance<<" "<<i<<" "<<iterativeTime<<endl;
  777 :
  778 :                         break;
  779 :                 }
  780 :         }
  781 :
  782 : }
  783 :
  784 : if(gridConvergenceStudy==true && transportSolverType=="monolithic")
  785 : {
  786 :         real bloodPDrop=(int1d(ThBlood,1)(y*pbh)-int1d(ThBlood,3)(y*pbh))/int1d(ThBlood,1)(y*1.);
  787 :         real dialPDrop=(int1d(ThDial,7)(y*pdh)-int1d(ThDial,5)(y*pdh))/int1d(ThDial,7)(y*1.);
  788 :         real wssMax=WSSVal[].max;
  789 :         wssMax=8.*wssMax;
  790 :         real bloodMeshSize=0;
  791 :         real dialMeshSize=0;
  792 :         for(int i=0; i<hBlood.n ; i++)
  793 :                 {bloodMeshSize=bloodMeshSize+hBlood[](i);}
  794 :         for(int i=0; i<hDial.n ; i++)
  795 :                 {dialMeshSize=dialMeshSize+hDial[](i);}
  796 :         bloodMeshSize=bloodMeshSize/hBlood.n;
  797 :         dialMeshSize=dialMeshSize/hDial.n;
  798 :
  799 :
  800 :         string gridConvFile;//="/Users/alexviguerie/Documents/MATLAB/Dialisi/Grid_Convergence/";
  801 :         gridConvFile=directory+meshAppend;
  802 :         ofstream gridDataOut(gridConvFile,append);
  803 :
  804 : //      gridDataOut <<n<<"      "<<bloodMeshSize<<"     "<<dialMeshSize<<"      "<<"    "<<2.*wssThresh<<"
"<<rapidity<<"  "<<tortuosity <<"       "<<bloodIn<<"   "<<bloodOut<<"  "<<dialIn<<"    "<<dialOut<<"   "<<clearance<<"
"<<monolithicTime<<endl;
  805 : //      cout <<n<<"     "<<bloodMeshSize<<"     "<<dialMeshSize<<"      "<<2.*wssThresh<<"      "<<rapidity<<"
"<<tortuosity <<"       "<<bloodIn<<"   "<<bloodOut<<"  "<<dialIn<<"    "<<dialOut<<"   "<<clearance<<" "<<monolithicTime<<endl;
  806 :         gridDataOut <<n<<"      "<<QhBlood.ndof+QhDial.ndof<<"  "<<2.*wssThresh<<"      "<<rapidity<<"  "<<tortuosity <<"       "<<bloodIn<<"   "<<bloodOut<<"  "<<dialIn<<"    "<<dialOut<<"   "<<clearance<<" "<<monolithicTime<<endl; 
  807 :         cout <<n<<"     "<<QhBlood.ndof+QhDial.ndof<<"  "<<2.*wssThresh<<"      "<<rapidity<<"  "<<tortuosity <<"       "<<bloodIn<<"   "<<bloodOut<<"  "<<dialIn<<"    "<<dialOut<<"   "<<clearance<<" "<<monolithicTime<<endl;
  808 : }
  809 : string dialString="ConcenDial";
  810 : string bloodString="ConcenBlood";
  811 :
  812 : ofstream writeBloodTransport(bloodTransportComputed);
  813 : ofstream writeDialTransport(dialTransportComputed);
  814 :
  815 : writeBloodTransport << cbh[];
  816 : writeDialTransport << cdh[];
  817 :
  818 : vtkScalarVariableExporter(cdh,"Concentration", ThDial,simResults,"ASimTestConc",dialString,".vtk")
    8 @
    9 @
   10 @
   11 @
   12 @
   13 @
   14 @
   15 @
   16 @
   17 @
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @
   24 @
   25 @
   26 @
   27 @
   28 @
   29 @
   30 @
   31 @
   32 @
   33 @
   34 @
   35 @
   36 @
   37 @
   38 @
   39 @
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @
   47 @
   48 @
   49 @
   50 @
   51 @
   52 @
   53 @
   54 @
   55 @
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @
   63 @
   64 @
   65 @
   66 @
   67 @
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @
   74 @
   75 @
   76 @
   77 @
   78 @
   79 @
   80 @
   81 @
   82 @
   83 @
   84 @
   85 @
   86 @
   87 @
   88 @
   89 @
   90 @
   91 @
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ {
    8 @                                 ofstream fileOutput(variablePath(simResults,"ASimTestConc",dialString,".vtk")
   ( ( (simResults+"ASimTestConc")+dialString ) +".vtk" )  );
    9 @                                 fespace VhC( ThDial, P2);
   10 @                                 VhC[int] uh(2);
   11 @                                 uh[0] = x;
   12 @                                 uh[1] = y;
   13 @
   14 @
   15 @                                 int nvertices =  ThDial.nv;
   16 @                                 int ntriangles =  ThDial.nt;
   17 @                                 int size = VhC.ndof;
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 @                                 fileOutput << "ASCII" << endl;
   26 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 @
   28 @
   29 @
   30 @
   31 @                                 real iter=0;
   32 @                                 fileOutput << "POINTS " << size << " double" << endl;
   33 @                                 for ( int i = 0; i < size; i++)
   34 @                                 {
   35 @                                         real Thx = uh[0][][i];
   36 @                                         real Thy = uh[1][][i];
   37 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 @                                 }
   39 @                                 fileOutput << endl;
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 @                                 for( int i = 0;i<ntriangles; i++)
   48 @                                         {
   49 @                                                 fileOutput << 3 << " ";
   50 @                                                 for(int j = 0; j<3;j++)
   51 @                                                 {
   52 @                                                         fileOutput << VhC(i,j) << " ";
   53 @                                                 }
   54 @                                                 fileOutput << endl;
   55 @                                         }
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 @                                 for(int i=0;i<ntriangles;i++)
   64 @                                 {
   65 @                                         fileOutput << "5 ";
   66 @                                 }
   67 @                                 fileOutput << endl;
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @                                 fileOutput << "POINT_DATA " << size << endl;
   74 @                                 fileOutput << " "<< endl;
   75 @                                 int narray = 1;
   76 @                                 string[int] name(narray);
   77 @                                 name[0] = "Concentration" ;
   78 @
   79 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 @
   81 @
   82 @
   83 @                                 fileOutput <<" " << endl;
   84 @                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 @                                                 for (int i =0; i< size ;i++)
   86 @                                                 {
   87 @
   88 @                                                         real Thx = uh[0][][i];
   89 @                                                         real Thy = uh[1][][i];
   90 @                                                         fileOutput << cdh(Thx,Thy) <<  endl;
   91 @                                                 }
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ }
  819 : vtkScalarVariableExporter(cbh,"Concentration", ThBlood, simResults,"ASimTestConc",bloodString,".vtk")
    8 @
    9 @
   10 @
   11 @
   12 @
   13 @
   14 @
   15 @
   16 @
   17 @
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @
   24 @
   25 @
   26 @
   27 @
   28 @
   29 @
   30 @
   31 @
   32 @
   33 @
   34 @
   35 @
   36 @
   37 @
   38 @
   39 @
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @
   47 @
   48 @
   49 @
   50 @
   51 @
   52 @
   53 @
   54 @
   55 @
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @
   63 @
   64 @
   65 @
   66 @
   67 @
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @
   74 @
   75 @
   76 @
   77 @
   78 @
   79 @
   80 @
   81 @
   82 @
   83 @
   84 @
   85 @
   86 @
   87 @
   88 @
   89 @
   90 @
   91 @
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ {
    8 @                                 ofstream fileOutput(variablePath( simResults,"ASimTestConc",bloodString,".vtk")
     ( ( ( simResults+"ASimTestConc")+bloodString ) +".vtk" )  );
    9 @                                 fespace VhC( ThBlood, P2);
   10 @                                 VhC[int] uh(2);
   11 @                                 uh[0] = x;
   12 @                                 uh[1] = y;
   13 @
   14 @
   15 @                                 int nvertices =  ThBlood.nv;
   16 @                                 int ntriangles =  ThBlood.nt;
   17 @                                 int size = VhC.ndof;
   18 @
   19 @
   20 @
   21 @
   22 @
   23 @                                 fileOutput << "# vtk DataFile Version 3.0 "<< endl;
   24 @                                 fileOutput << "output.vtk, Created by Freefem++" << endl;
   25 @                                 fileOutput << "ASCII" << endl;
   26 @                                 fileOutput << "DATASET UNSTRUCTURED_GRID" << endl;
   27 @
   28 @
   29 @
   30 @
   31 @                                 real iter=0;
   32 @                                 fileOutput << "POINTS " << size << " double" << endl;
   33 @                                 for ( int i = 0; i < size; i++)
   34 @                                 {
   35 @                                         real Thx = uh[0][][i];
   36 @                                         real Thy = uh[1][][i];
   37 @                                         fileOutput << Thx  << " " << Thy << " " << 0 << endl;
   38 @                                 }
   39 @                                 fileOutput << endl;
   40 @
   41 @
   42 @
   43 @
   44 @
   45 @
   46 @                                 fileOutput << "CELLS " << ntriangles<< " "<< 4*ntriangles << endl;
   47 @                                 for( int i = 0;i<ntriangles; i++)
   48 @                                         {
   49 @                                                 fileOutput << 3 << " ";
   50 @                                                 for(int j = 0; j<3;j++)
   51 @                                                 {
   52 @                                                         fileOutput << VhC(i,j) << " ";
   53 @                                                 }
   54 @                                                 fileOutput << endl;
   55 @                                         }
   56 @
   57 @
   58 @
   59 @
   60 @
   61 @
   62 @                                 fileOutput << "CELL_TYPES " << ntriangles << endl;
   63 @                                 for(int i=0;i<ntriangles;i++)
   64 @                                 {
   65 @                                         fileOutput << "5 ";
   66 @                                 }
   67 @                                 fileOutput << endl;
   68 @
   69 @
   70 @
   71 @
   72 @
   73 @                                 fileOutput << "POINT_DATA " << size << endl;
   74 @                                 fileOutput << " "<< endl;
   75 @                                 int narray = 1;
   76 @                                 string[int] name(narray);
   77 @                                 name[0] = "Concentration" ;
   78 @
   79 @                                 fileOutput << "FIELD " << "FieldData " << narray << endl;
   80 @
   81 @
   82 @
   83 @                                 fileOutput <<" " << endl;
   84 @                                 fileOutput << name[0] << " 1 " << size <<" double" << endl;
   85 @                                                 for (int i =0; i< size ;i++)
   86 @                                                 {
   87 @
   88 @                                                         real Thx = uh[0][][i];
   89 @                                                         real Thy = uh[1][][i];
   90 @                                                         fileOutput << cbh(Thx,Thy) <<  endl;
   91 @                                                 }
   92 @
   93 @
   94 @
   95 @
   96 @
   97 @
   98 @ }
  820 :  sizestack + 1024 =306720  ( 305696 )
 
Enter torturosity
0.125
Enter wss threshold
50
  --  mesh:  Nb of Triangles =  45194, Nb of Vertices 24214
  --  mesh:  Nb of Triangles =  88249, Nb of Vertices 45741
  number of required edges : 0
 write geo in ./DialMesh.mesh.gmsh
  number of required edges : 0
 write geo in ./BloodMesh.mesh.gmsh
Computing flow solutions...
 try getConsole C:\Users\P70073624\Desktop\SangitaStuff\SangitaStuff\MicroScaleCodePreconditioningStudy.edp
